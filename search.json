[{"title":"线性代数","url":"/2022/ComputerGraphic/cg_linear_algebra/","content":"复习复习线代\n向量\n\n\n\n\n向量具有两个属性:\n\n方向: \n长度: \n\n单位向量:\n\n长度为 1 的向量\n求单位向量: \n常用于查找方向\n\n\n向量求和\n\n\n平行四边形法则\n三角形法则\n\n\n假装有个坐标轴\n\n\n\n\n向量点乘与叉乘点乘\n\n\n\n向量点乘:    \n\n\n点乘满足交换律, 结合律, 分配律\n\n2D 下:\n\n3D 下:\n\n投影:\n\n\n\n\n投影:   \n向量 k:   \n\n叉乘在图形学中, 叉乘用于判断 左/右, 内/外\n\n矩阵矩阵相乘无交换律\n\n\n\n\n始终认为向量为列向量, 矩阵在左, 向量在右\n2D 变化: \n\n矩阵转置:\n\n\n\n单位矩阵:\n\n","categories":["ComputerGraphic"]},{"title":"C 语言","url":"/2023/C-language/c_language/","content":"概述C 语言是一个中等级语言, 在机器语言和汇编语言之上, 在其他高级语言之下大部分语言的编译器的内核都是用 C 构建的 (例: python, java, C#, C++, js)\n\n\nC 语言不是面向对象的编程语言\nC++是 C 语言的扩展\n\nC 语言对初学者还挺难的(¬‿¬)\n\n开始stdio.h 包含一些关于输入输出的函数\n// 预处理命令, 告诉编译器包含哪些文件#include &lt;stdio.h&gt;// main函数 程序入口点int main()&#123;    return 0;&#125;\n\n\n在命令行中使用编译器gcc &quot;源码文件&quot; -o &#x27;输出文件名&#x27;\n\n注释/** * 多行 * 注释 */// 单行注释\n\n\n变量\nsigned 有符号数据 (默认数据)\nunsigned 指代无符号数据\nshort 短数据\nlong 长数据 (默认数据)\nlong long 长长数据\n\n要使用变量类型 bool 需要引入 stdbool.h 头文件\n#include &lt;stdbool.h&gt;\n\nint x = 123;int y = 321;int age = 22; // 4 bytes (-2147483648 ~ 2147483647)float gpa = 2.05; // 4 byteschar grade = &#x27;C&#x27;; // 1 byte (-128 ~ 127) %dchar name[] = &quot;Bro&quot;; // 字符串// 还有更多数据类型double d = 3.141592653589793; // 8 bytesbool b = true; // 1byte (true false) %dunsigned char g = 255; // 1 byte (0 ~ 255) %dshort int h = 32767; // 2 bytes (-32768 ~ 32768) %dunsigned short int i = 65535; // 2 bytes (0 ~ 65535) %ulong int l; // 4 bytes 默认状态下, 这些就是 long 数据, 不需显式输入long long int ll = 4656454654654654654654546U; // 8 bytes 记得在最后加个U, 否则编译器会发出warning\n\n\n格式化输出:\n// 标志(flag) &quot;-&quot;, &quot;+&quot;, &quot;0&quot;, &quot;,&quot;// - :左对齐// + :输出正负符号// 0 :用0填充数字// , :数字大于1000, 用&quot;,&quot;隔开% &lt;标志&gt; &lt;宽度&gt; &lt;精度&gt; &lt;格式化类型&gt;// 精度 .2 显示后两位float f = 3.1415;long long int ll;// 例:printf(&quot;float: %f&quot;, f);printf(&quot;long long data: %lld&quot;, ll);\n\n\n\n\nType\n格式化\n\n\n\nunsigned\n%u\n\n\nlong\n%l\n\n\nint\n%d\n\n\nfloat\n%f\n\n\ndouble\n%lf\n\n\nchar\n%c\n\n\nchar[]\n%s\n\n\n%\n%%\n\n\n\n常量, 常量在程序中不可改变\n// 常量一般用大写字母表示const float PI = 3.14159;\n\n\n用户输入\nscanf 不会读取空格\nfgets\n\n注: &amp; 为取地址符\n// 获取用户输入的函数// scanf(格式化字符串, 变量地址)scanf(&quot;%d&quot;, &amp;age);// fgets(变量名, 数值大小, stdin);// 这样获取字符串会把 \\0 获取下来// \\0: 字符串结束符fgets(name, 25, stdin);\n\n#include &lt;string.h&gt;// 获取字符串长度strlen()\n\n\n数学运算#include &lt;math.h&gt;sqrt(9); // 开方 9的开方pow(2, 4); // 幂运算 2的4次方round(3.14); // 四舍五入ceil(3.14); // 向上取整floor(3.14); // 向下取整fabs(-100); // 取绝对值log(3); // 对数运算 以2为根, 3的对数// 三角函数sin(45);cos(45);tan(45);\n\n流程控制if 语句好像没什么说的…\nif (true)&#123;    // code ...&#125;else if(false) &#123;    // code ...&#125;else&#123;    // code ...&#125;\n\n\nswitch 语句\nint choice;switch (choice)&#123;    case 1:        // code ...        break;    case 2:        // code ...        break;    default:        //code ...&#125;\n\n\n逻辑运算符\n&amp;&amp; 且\n|| 或\n! 非\n\n三元运算符int min;int max;int result;result = (max &gt; min) ? max : min;\n\n函数// 无参函数void myFunction()&#123;    printf(&quot;I&#x27;m function!&quot;);&#125;int main()&#123;    // 调用函数    myFunction();    return 0;&#125;\n\n参数:\n// 变量会在参数处声明void myFunction(int num)&#123;    printf(&quot;I&#x27;m function! and my argument is %d&quot;, num);&#125;\n\n\n原型函数, 是一个函数声明, 在主函数之前的没有函数体的函数\n该函数的主要作用是确保函数的参数正确(让编译器不忽略错误的传参)\n\n字符串函数要使用字符串函数, 需包含 string.h 头文件\n#include&lt;string.h&gt;char string1[] = &quot;Hi&quot;;char string2[] = &quot;my name is voilone&quot;;// 将字符转换为大小写strlwr();strupr();strcat(sring1, string2); // 将两个字符拼接, 结果会返回个string2strcopy(string1, string2);  // 将string2 复制到 string1strncopy(string1, string2, n); //将 string2 的 n 个字符复制到 string1strset(string1, &#x27;?&#x27;); // 将所有字符换为指定的字符strnset(string1, &#x27;?&#x27;, 1) // 将 n 个字符换为指定的字符strrev(string1); // 反转字符串\n\nstrlen(); // 获取字符串长度strcmp(); // 对比字符串, 如果相同, 返回0, 否则是其他数字strncmp(); // 对比 n 个字符串strcmpi(); // 对比所有字符串, 忽略字符串大小写strnicmp() // 对比 n 个字符串, 忽略字符串大小写\n\n\n循环\ncontinue 跳过一个循环\nbreak 跳出整个循环\n\n\nfor 循环for (int i; i &lt; 10; i++)&#123;&#125;\n\n\nwhile 循环while (true)&#123;&#125;\n\n\ndo while 循环#include&lt;stdbool.h&gt;bool judge = false;do&#123;    judge = true;&#125;while (judeg)&#123;    // code ...&#125;\n\n\n数组// 声明 一double prices[3] = &#123;2.2, 5.5, 6.6&#125;;// 声明 二int nums[2];nums[0] = 1;nums[1] = 2;// 访问prices[0];\n\nint array[] = &#123;1, 2, 3&#125;// 获取数组长度sizeof(array)\n\n\n二维数组// 二维数组int numbers[2][3] = &#123;                    &#123;1, 2, 3&#125;,                    &#123;2, 3, 3&#125;                    &#125;;\n\n\n字符串数组#include &lt;string.h&gt;char chars[][20] = &#123;&quot;hello&quot;, &quot;This char array&quot;&#125;;// 替换数组中的字符串strcopy(chars[0], &quot;New string~&quot;);\n\n\nstruct 数据集合struct 结构体\nstruct 是一些数据的集合, 每个单一的数据被称为: “成员(member)”\n// 声明结构体struct Player&#123;    char name[12];    int score;&#125;struct Player player1;struct Player player2;// 访问结构体, 并对其赋值strcopy(player1.name, &quot;voilone&quot;);player1.score = 55;\n\nstruct 数组struct Student&#123;    char name[12];    float gpa;&#125;struct Student student1 = &#123;&quot;voilone&quot;, 3.0&#125;;struct Student student2 = &#123;&quot;sam&quot;, 2.0&#125;;struct Student student3 = &#123;&quot;xv&quot;, 4.0&#125;;struct Student students[] = &#123;student1, student2, student3&#125;;\n\n\ntypedeftypedef 可以给关键字一个别称\n// 别称 usertypedef char user[25]user user1[25] = &quot;voilone&quot;;\n\n// 不使用 typedefstruct User&#123;    char name[25];    char password[12];    int id;&#125;struct User user1 = &#123;&quot;voione&quot;, &quot;654321&quot;, 666&#125;;//------------------------------------------// 使用 typedeftypedef struct &#123;    char name[25];    char password[12];    int id;&#125; User;User user2 = &#123;&quot;voione&quot;, &quot;654321&quot;, 666&#125;;\n\n\nenmu 枚举类型一种用户自定义命名的整数数据, 使其代码更有可读性\nenum Day&#123;Sun = 1, Mon = 2, Tue = 3, Wed = 4, Thu = 5, Fri = 6, Sat = 7&#125;;enum Day today = Sun;// 打印结果: Today is 1printf(&quot;Today is %d&quot;, today)\n\n位运算符\n&amp;\n|\n^\n&lt;&lt;\n&gt;&gt;\n\n\n内存地址\nmemory 一个字节数组\nmemory block 一个单元的内存(byte), 用于储存数据\nmemory address 内存块的地址\n\n&amp; 取地址符\nchar a = &#x27;X&#x27;;char b = &#x27;Y&#x27;;char c = &#x27;Y&#x27;;// 打印变量大小printf(&quot;%d bytes&quot;, sizeof(a));// 打印内存地址, %p// 打印出的内存地址用16进制表示printf(&quot;%p&quot;, &amp;a)\n\n\n指针pointer 指针保存一个变量的内存地址* 为解引用操作符\nint age = 21;// 使用 &quot;*&quot; 储存内存地址// p: pointerint *pAge = &amp;age;printf(&quot;address: %p&quot;, &amp;age);prinft(&quot;pAge value: %p&quot;, pAge);printf(&quot;value: %d&quot;, age);printf(&quot;pAge point to value %d&quot;, *pAge)  // 解引用// 也可采用NULL来声明指针int *pAge2 = NULL;pAge2 = &amp;age;\n\n\n函数与指针\nvoid printAge(int *pAge)&#123;    printf(&quot;you are %d olds&quot;, *pAge);&#125;;\n\n\n其他随机数要生成随机数, 需要包含 stdlib.h 头文件\n#include &lt;stdlib.h&gt;// 随机数的生成前置条件// ?srand(time(0));// rand() 函数 随机返回 0 ~ 32767 的整数int number1 = (rand() % 6) + 1;\n\n\n文件 czfopen(path, mode) 模式:\n\nw 覆盖写入\na 添加\nr 读取\n\n检测是否存在文件:\nFILE *pF = fopen(&quot;test.txt&quot;, &quot;r&quot;);if (pF == NULL) printf(&quot;No such file!&quot;);\n\n写入文件// 写入数据// fopen(&quot;文件路径&quot;, 模式)FILE *pF = fopen(&quot;test.txt&quot;, &quot;w&quot;);// 写入数据fprintf(pF, &quot;some fromat text&quot;);// 关闭文件fclose(pF);\n\n文件删除:\n// 成功删除, 返回 0remove(&quot;test.txt&quot;);\n\n\n读取文件FILE *pF = fopen(&quot;test.txt&quot;), &quot;r&quot;;// 声明缓冲区char buffer[255];// 读取单行文本// fget(缓冲区, 最大大小, 文件地址)fget(buffer, 255, pF);// 读取多行//! 注意, 此处为fgets()while (fgets(buffer, 255, pF) != NULL)&#123;    printf(&quot;%s&quot;, buffer)&#125;\n","categories":["C language"]},{"title":"CSS Flex布局","url":"/2022/CSS/css_flex/","content":"FLEX 布局CSS 的一场进化\n\nflex 概览flexbox 是 CSS3 的一个新模块, 特别适合于元素之间的对齐.flexbox 给予元素扩展和收缩的能力, 从而更好的利用显示空间.\n\nflex 容器(flex container)\nflex 项目(flex item) – flex 容器的子元素\n\n\nflex 容器属性flex-direction—-决定主轴方向justfiy-content—-决定 flex 项目如何与主轴对齐align-item—-决定 flex 项目如何与副轴对齐\n\nflex-warp—-决定 flex 项目是否换行(在没有足够空间的情况下)align-content—-仅适用于多排的 flex 项目\n\n\n\nflex 物件align-self—-决定单一 flex 项目的对齐方式order—-决定 flex 项目的排序\n\n决定 flex 项目的宽度:简写: flex: 0 1 auto;flex-grow—-flex 项目增长大小flex-shrink—-flex 项目收缩大小flex-basis—-定义 flex 项目的基本大小\n\n\nTrillo 项目#复制package.json到项目文件#然后执行:npm install\n\n\n可能有用的网站CodePen:https://codepen.iosvg 图片: https://icomoon.io贝塞尔曲线网站:https://cubic-bezier.com\n","categories":["CSS"]},{"title":"MariaDB","url":"/2023/DataBase/db_mariadb/","content":"用户管理创建用户-- 也可在 openstack@192.168.233.124 改为 openstack@192.168.233.%-- 意为允许在 192.168.233.0 这个网段登录CREATE USER example_user@192.168.233.124 IDENTIFIED BY &quot;123456&quot;;\n\n\n权限管理GRANT ALL PRIVILEGES ON example_database.* TO  example_user@192.168.233.124\n\n\n远程连接数据库连接前的准备操作用户 HOST 数据位置 mysql.user查看用户所对应的 HOST\nSELECT user,host FROM mysql.user;\n\n远程连接# -h hostName 远程连接的域名mysql -h &quot;&quot;\n","categories":["DataBase"]},{"title":"Git & GitHub","url":"/2023/Git/git_basic/","content":"GitGit 官网: https://git-scm.com\nGit: 代码版本管理工具\n\n版本控制系统\n管理代码历史\n跟踪代码变化\n\n通过时间控制和跟踪代码变化1\n\nGit 的工作方式工作目录: 使用的项目文件都将由 git 管理的目录\n\n第一次 commit: 类似于快照, 将所有的文件保存下来\n第二次commit: 只将有改动的文件内容保存下来, 而不是保存文件本身\n当工作目录新增文件时第三次commit: 新增的文件将被保存\n\n分支:默认情况下, git 会将你的更改提交至 master 分支(main 分支)\n当想要在主分支的基础上开发新的东西, 而不影响主分支的代码, 就需要用到分支分支可以创建完全独立的工作目录, 是主分支的完整副本分支可以合并至主分支\n工作树:\nflowchart TB1[主分支] --&gt; 分支11[主分支] --&gt; 分支21[主分支] --&gt; ...分支1 --合并--&gt; 2[主分支]\n\n在 git 管理的目录下会有有个 .git 的隐藏目录, 这个目录被称为 git 仓库\ngit 仓库包含两个不同的区域:\n\n暂存区, 一个索引文件\n可以将其看作是草稿区, 用于暂存代码的改变\n\n\n对象文件夹, 包含不同的 commit\n保存实际的文件和跟踪的改变\n\n\n\ngraph LR工作目录 --add--&gt; 暂存区 --commit--&gt; 对象文件夹\n\n\n仓库初始化 和 提交 Commit如果想要 git 管理工作目录, 需要初始化 git 仓库\n# 查看git仓库信息git status# 仓库初始化git init\n\n将文件加入暂存区\ngit add &lt;文件&gt;# 一个例子git add ./\n\n提交至 git 仓库\n# -m 选项: 提交的信息# -m (message)git commit -m &lt;备注的信息&gt;\n\n如果没有为 git 配置用户名和邮箱, commit 会报错\ngit config --global user.email &lt;电子邮箱地址&gt;git config --global user.name &lt;用户名&gt;\n\n查看提交信息\ngit log# 示例:# 输出的信息commit 3e3ce608e2a283a807a208ed734bc1659a91d3e8 (HEAD -&gt; master)    # 提交idAuthor: voilone &lt;voilone@qq.com&gt;Date:   Sun Jan 8 23:26:20 2023 +0800    first commit\n\n如果有多个 commit, 而你想跳转到一个指定的 commit先查看并复制 commit 的 id然后:\ngit checkout &lt;commit ID&gt;\n\n当跳转到指定的 commit用 git log 指令将不会看到指定 commit 后的 commit但这并不意味着后面的 commit 被删除了\n# 跳回分支 master 最后的commitgit checkout master# 会发现, git log 命令又恢复显示回所有的 commit 了\n\n\n分支 Branches创建的第一个分支, 默认名称为 master\n# 查看现有分支git branch\n\n创建分支\n# 分支名不允许有空格git branch &lt;分支名&gt;# 或git checkout -b &lt;分支名&gt;# 例:git branch second-branch\n\n切换至指定的分支\ngit checkout &lt;分支名&gt;\n\n在新建的分支 2 下git log 命令会显示与主分支一模一样的 commit 包括 commit id\n\n合并分支将分支合并至主分支\n# 将指定分支合并至当前分支git merge &lt;指定的分支&gt;\n\n\n新命令新命令主要是功能与命令相契合, 便于理解和使用\n如果使用的 git 版本 &gt;&#x3D; 2.23就可以使用这些新命令\n# 查看 git 版本git -v\n\n切换和创建分支\n# 切换分支git switch &lt;分支名&gt;# 创建分支git switch -c &lt;分支名&gt;\n\n\nHEAD使用 git log 我们会发现在一些 commit 后面会有一个 (HEAD -&gt; 分支1, 分支2, ...)\n最后一次 commit 称之为 head, 这是一个默认行为\nflowchart LRother --- co1h2(HEAD) --&gt; co3subgraph commits2co1(&quot;commit1&quot;) --&gt; co2(&quot;commit2&quot;) --&gt; co3(&quot;commit3&quot;)endmaster --- commit1h1(HEAD) --&gt; commit3subgraph commitscommit1(&quot;commit1&quot;) --&gt; commit2(&quot;commit2&quot;) --&gt; commit3(&quot;commit3&quot;)end\n\n分离 HEADHEAD 不关心分支, 只关心 commit 的 id\n当一个 commit 不独属于一个分支时checkout 指定的 commit id, 会引起 HEAD 分离, 即 detached HEAD 状态2\ngit checkout &lt;commit id&gt;# 这样会可能进入 分离 HEAD 状态\n\n\n删除与撤销删除跟踪的文件从工作目录中删除跟踪的文件\n# 查看哪些文件属于暂存区git ls-files# 将指定文件从暂存区删除git rm &lt;文件名&gt;\n\n\n撤消操作当文件做出更改时, 你想将指定文件回到最后一次 commit 状态\n# 将指定文件回归到最后一次 commit 的状态# --代表没有指定分支git checkout -- &lt;文件名&gt;# 简写git checkout  &lt;文件名&gt;# 例:# 将当前文件夹恢复至最后一次提交的状态git checkout -- ./\n\n\n新命令等价于 git checkout -- &lt;文件名&gt;:\ngit restore &lt;文件名&gt;\n\n\n删除未跟踪的文件# 删除指定未跟踪的文件git clean &lt;文件&gt;# 列出将要删除的文件git clean -dn# 删除所有未跟踪的文件git clean -d# 忽略提醒并删除# -f 强制git clean -df\n\n\n撤销提交到暂存区的文件在将文件提交到暂存区后, HEAD 会指向暂存区如果使用 git checkout 命令进行撤销, 将不会起作用\ngit reset 将文件的最新 commit 存放到暂存区\ngit reset &lt;文件名&gt;# 然后再进行撤销git checkout &lt;文件名&gt;\n\n\n新命令git reset  命令等价于:\ngit restore --staged &lt;文件名&gt;\n\n\nGit Stash基础使用当你想保存当前代码进度而又不想提交或创建新分支时你可以用到 git stash\ngit stash 的基本运用:\n# 执行这条命令后, 工作目录会跳回到最新的提交git stash# 执行这条命令后# 工作目录恢复到 执行 git stash 前的状态git stash apply\n\n\n更多用法列出多个 stash:\ngit stash list# 输出stash@&#123;0&#125;: WIP on master: 8adf4dd file1 added# 应用指定下标的 stashgit stash apply &#123;0&#125;\n\n\n创建 stash 时还可添加备注\ngit stash push -m &quot;这是备注&quot;\n\n\n如果想将 stash 中的内容加入到暂存区, 需要将其弹出\ngit stash pop [stash_下标]\n\n删除某个 stash:\ngit stash drop  [stash_下标]# 想删除所有 stashgit stash clear\n\n\nGit Reflog如果误删一个提交或一个分支, 可使用 git reflog 恢复需要注意, 恢复的有效期只有 30 天\n# 删除的提交会恢复git reflog\n\n恢复分支\n# 先从该命令的输出中查找你要恢复的分支哈希值git reflog# 先分离 HEADgit checkout [哈希值]# 然后再创建分支git switch -c [分支名]\n\n\n合并分支分支合并感觉稍微有点复杂, 使用使用时还需复习下\n合并类型:\n\n快进合并 (Fast Forward)\n非快进合并 (Non Fast Forward)\n递归合并\n. . .\n\n快进合并主分支不改动(即没有任何新的提交), 分支提交改变.在这种情况下合并分支就被称为快进合并\ngit switch master# 快速合并git merge [分支名]\n\n这样的合并不会创建新的提交, 也就意味着 HEAD 会同时指向主分支和改变的分支\n# 进入主分支git switch master# 将分支的改变加入到主分支的暂存区git merge --squash [分支名]git commit -m &quot;...&quot;\n\n\n非快进合并(递归合并)主分支有额外提交, 同时其他分支也有额外提交,这个时候会用到非快速合并\n使用非快速合并, 两个分支将会被合并为一个分支, 并添加至主分支\n# --no-ff 非快速合并git merage --no-ff [分支]\n\n\nGit Rebaserebase 不是移动提交, 而是创建新的提交\n注意: 不要在你的本地仓库外 rebase 提交\ngit branch 其他分支git rebase 主分支\n\nrebase 通过检测两个分支的同一个起点, 然后基于同一个起点,将其他分支的进度创建至主分支\n\n合并冲突有很多潜在的合并冲突, 最容易想到的是不同分支的同一个文件的同一个位置被同时修改导致的合并冲突\n当发生合并冲突时, 发生冲突的文件会显示冲突的细节如果使用 VS Code, VS Code 会给出四个选项来处理冲突:\n\n不接受合并改变 (Accept Current Changes)\n接受合并后的改变 (Accept Incoming Changes)\n接受两个改变 (AcceptBoth Changes)\n比较变化 (Compare Changes)\n\n当然, 也可以手动删除你不想要的冲突, 然后将文件添加到暂存区,然后提交(合并)\n# 查看冲突状态git status# 查看具体的冲突git diff# 终止合并git merge --abort# 可以查看到两个将要合并的提交git log --merge\n\n要解决冲突, 就是手动删除你不想要的冲突, 然后 add ./, 然后 commit\n\n合并, Rebase, Cherry Pick 的比较\nCherry Pick\n假设这么一种情况, 如果你的主分支出现一些代码上的拼写错误, 而你在分支上修复了它现在, 你只想将修复了的提交合并至主分支,而不是分支上的所有修改, 这个时候就可以用到 cherry-pick\n# 假设分支上有两个提交# 现在我们只想合并 commit 1 至主分支commit 2 (HEAT -&gt; git-branch)...    new-feturecommit 1...    fixed typo\n\ncherry-pick 复制提交, 并生成一个新的提交 ID\n# 回到主分支git switch master# 合并指定分支git cherry-pick 分支提交ID# 例:# 将上面分支的 commit 1 合并到主分支git switch mastergit cherry-pick 1\n\n\n总结\n\nGit 标签 (git tag)假设我们的 Git 仓库有很多提交, 其中有些提交是一些代码的最终版本(比如版本 1.0, 版本 2.0 …)我们可以通过添加 Git 标签来快速定位到这些提交\n标签类型:\n\n轻量标签\n注释标签 (完整的 tag 对象)\n\n# 显示所有的标签git tag# 添加轻量标签git tag 标签名 提交ID# 添加注释标签git tag -a 标签名 &#x27;注释信息&#x27;# 显示Git 标签git show 标签名# 删除轻量标签git tag -d 标签名\n\n进入标签标记的提交\ngit checkout 标签名\n\n\nGitHubGitHub 官网: https://github.com\nGitHub:\n\n最大的开发平台\n云托管与云协作的服务商\nGit 存储库的托管服务商\n\n\n概念\n本地仓库 git\n远程仓库 GitHub\n\n远程仓库可以是 GitHub 或其他代码托管平台(比如 Gitea, Gitlab….)\n# 添加远程仓库# 这里的 origin 指的是远程仓库的别名git remote add origin 远程仓库地址\n\n# 将本地信息上传至远程仓库git push# 本地仓库与远程仓库同步git pull\n\n\n\n1.不仅仅是代码, 也可以是其它类型的文件 ↩2.放心, 这样没有任何问题 ↩","categories":["Git"]},{"title":"初识Git","url":"/2022/Git/git_starter/","content":"git 的基本使用\n配置用户和邮箱这是使用 git 的第一步\ngit config --global user.name   &quot;用户名&quot;git config  --global  user.email  &quot;邮箱地址&quot;\n\ngit 常用命令git init        # 在当前目录创建git管理git add &lt;文件&gt;  # 将文件加入暂存区git commit      # 将文件提交至本地厂库git status      # 查看文件状态git log         # 查看源码版本(按q退出)\n\n\n文件忽略设置在工作目录下创建 .gitignore 文件.gitignore 文件:用于写入需要忽略提交的文件名, 用户需自行创建\n例:\n# .gitignore文件# 忽略files文件夹files/\n\n查看忽略的文件\ngit status --ignore\n\n\n细节git add ./                  # 将当前目录加入暂存区git commit -m &quot;备注&quot;        # -m选项, 添加备注\n\n删除暂存区git rm -r --cached &lt;文件路径&gt;       #删除暂缓区\n\n\n远程仓库git clone  &lt;https链接&gt;                  # 从远程厂库拷贝至本地git remote add origin &lt;http链接&gt;        # 建立本地仓库与远程仓库的联系# 查看本地仓库与远程仓库的联系(origin代表远程仓库的名字)git remote  -vgit branch -M mai                       # 将当前分支重命名为maingit push -u origin &lt;远程仓库分支名&gt;\t # 为git设置上传流\n\n# 上传至远程仓库git push\n\n\n分支管理# 删除暂存区git rm --cached &lt;文件名&gt;\n\ngit branch                  # 查看分支git branch 分支名           # 创建新分支git checkout -b 分支名      # 创建并切换至指定分支git checkout 分支名         # 切换至指定分支git branch -d 分支名\t    # 删除指定分支(选项 -D, 确定删除分支)git commit -a -m 备注       # 将分支合并至主分支master(主支无变化)git merage 分支名           # 将其他分支合并到当前分支\n","categories":["Git"]},{"title":"Java基础操作","url":"/2022/Java/java_basic/","content":"介绍\n学习 JAVA 的理由:\n\n全球最受欢迎的编程语言之一\n是一种极为灵活的编程语言\n好找工作\n\n\n概念java 编译流程\ngraph LR.java源码 --编译--&gt; .Class字节码 --JVM--&gt; 机器码\n\nJDK, JRE, JVM缩写名词解释\n\nJDK—-Java Development Kit—-java 开发工具\nJRE—-Java Runtime Env.—-java 的运行环境(库和工具)\nJVM—-Java Virtual Machine—-java 虚拟机(运行 java 程序)\n\ngraph LRJDK --- JRE --- JVM\n\n\nIDE—-Integrated Development Environment—-集成开发环境java SE java 标准版\n\nIDE 推荐Eclipse 或 Intellij IDEA\n\n\nEclipse快捷输入:sysout + alt + / &#x3D; System.out.println(&quot;test&quot;)\n//一个一个字母写太慢System.out.println(&quot;test&quot;)\n\n基础变量\n\n\n数据类型\n大小\n初始&#x2F;引用\n值\n\n\n\nboolean\n1 bit\n初始\ntrue&#x2F;false\n\n\nint\n4 bit\n初始\n\n\n\ndouble\n8 bit\n初始\n\n\n\nchar\n2 byte\n初始\n\n\n\nString\nvaries\n引用\n\n\n\n\n初始值\n\n8 个类型\n储存数据\n只能储存一个值\n内存占用小\n快\n\n\n引用值\n\n无限制\n储存内存地址\n可以储存更多值\n内存占用大\n慢\n\n\n\nint x =123;float y = 3.14f;boolean z = true;char symbol = &#x27;@&#x27;;String name = &quot;Bro &quot;;System.out.println(&quot;Hello &quot;+name);\n\n用户输入Scanner 扫描器\n//使用Scanner时需要导入对应的包import java.util.ScannerScanner  scanner = new Scanner(System.in);String name = scanner.nextLine();\n\n\nJava GUI//首先先导入包import javax.swing.JOptionPane;...String name = JOptionPane.showInputDialog(&quot;Enter your name&quot;);   //弹出对话框, 返回一个字符串JOptionPane.showMessageDialog(null, &quot;Hello &quot;+name);             //弹出输入后的提示//Integer.parseInt()将函数返回值转化为整型int age = Integer.parseInt(JOptionPane.showInputDialog(&quot;Enter your age&quot;));JOptionPane.showMessageDialog(null, &quot;You are &quot;+age+&quot; years old&quot;);\n\n\n数学包double x = 3.14;double y = 10;//比较大小, 返回大的数, 同理.min()Math.max();Math.abs();     //返回绝对值Math.sqrt();    //平方根Math.round();   //四舍五入Math.ceil();    //向上取整Math.floor();   //向下取整\n\n随机数import java.util.Random;...//伪随机数Random random = new Random();int x = random.nextInt(100);        //将随机限制在0~100double x = random.nextDouble();...\n\n\n数组String[] cars = &#123;&quot;Camaro&quot;, &quot;Corvette&quot;, &quot;Tesla&quot;&#125;;String[] cars = String[3];#二维数组String[][] cars = &#123;&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;,                   &#123;&quot;4&quot;, &quot;5&quot;, &quot;6&quot;&#125;,                  &#125;;String[][] cars = [3][3];\n\n字符方法String name = &quot;Bro&quot;;name.equals(&quot;Bro&quot;);         //判断字符相同name.equalsIgnoreCase();    //忽略大小写name.length();              //获取字符长度name.charAt();              //通过下标获取字符name.indexOf();             //通过字符获取下标name.isEmpty();             //判断字符是否为空//转换大小写name.toUpperCase();name.toLowerCase();name.trim();                //删除空格name.replace(&quot;&lt;替换前&gt;&quot;, &quot;&lt;替换后&gt;&quot;);      //替换字符\n\n包装类(wrapper class)封装类要慢于原始数据类型, 但封装类可以调用许多方法\n// 自动装箱和自动拆箱// 封装类会被JAVA编译器自动拆箱和封箱// 使其自然的切换封装类或原始数据类型Boolean a = true;Character b = &#x27;@&#x27;;Integer c = 123;Double d = 3.14;\n\n\n\n\n原始数据类型\n封装类\n\n\n\nboolean\nBoolean\n\n\nchar\nCharacter\n\n\nint\nInteger\n\n\ndouble\nDouble\n\n\n\n数组列表一个可调整大小的数组, 数组内的数据可以在其编译后加入和删除但注意, 数组列表只储存引用数据类型\nimport java.util.ArrayList;// 声明数组列表ArrayList&lt;String&gt; food = new ArrayList&lt;String&gt;();food.add(&quot;pizza&quot;);food.add(&quot;hamburger&quot;);food.add(&quot;hotdog&quot;);// 替换数组列表的元素// 删除, 清除food.set(0, &quot;sushi&quot;);food.remove(2);food.clear();// 数组列表的长度用.size()获取// 数组列表的元素用.get()获取for(int i=1; i&lt;food.size(); i++)&#123;    System.out.println(food.get(i));&#125;\n\n\n二维数组列表一个动态的嵌套数组, 你可以在运行时改变数组大小\nimport java.util.*;...// 二维数组列表ArrayList&lt;ArrayList&lt;String&gt;&gt; groceryList = new ArrayList();ArrayList&lt;String&gt; backeryList = new ArrayList();backeryList.add(&quot;pasta&quot;); backeryList.add(&quot;garlic bread&quot;);backeryList.add(&quot;donuts&quot;);ArrayList&lt;String&gt; produceList = new ArrayList();produceList.add(&quot;tomatoes&quot;); produceList.add(&quot;zucchini&quot;);produceList.add(&quot;peppers&quot;);ArrayList&lt;String&gt; drinksList = new ArrayList();drinksList.add(&quot;soda&quot;); drinksList.add(&quot;coffee&quot;);groceryList.add(backeryList); groceryList.add(produceList);groceryList.add(drinksList);System.out.println(groceryList);\n\n\nforeach 循环增强的 for 循环\nString[] animals = &#123;&quot;cat&quot;, &quot;dog&quot;, &quot;rat&quot;, &quot;bird&quot;&#125;;// for (元素:列表名)for(String i : animals) &#123;    System.out.println(i);&#125;// foreach 循环同样适用于数组列表ArrayList&lt;String&gt; otherAnimals = new ArrayList();otherAnimals.add(&quot;cat&quot;); otherAnimals.add(&quot;dog&quot;)\n\n方法, 函数(method)相当于其他编程语言的函数\n// void 函数返回类型static void hello(String name) &#123;    System.out.println(&quot;Hello &quot;+name);&#125;// 调用函数hello(&quot;Bro~&quot;);\n\n\n重载方法拥有同一个名字的多个方法; 但形参不同, 具体方法不同例:\nstatic int add(int a, int b)&#123;    return a + b;&#125;static int add(int a, int b, int c)&#123;    return a + b + c&#125;static int add(int a, int b, int c, int d)&#123;    return a + b + c + d&#125;\n\n\nprintf 格式化输出Java 的格式化输出1\n// .printf(格式化文字, 参数)System.out.printf(&quot;This is a format string %d&quot;, 123);\n\n\n\n\n格式化\n符号\n\n\n\n十进制数\n%d\n\n\n浮点数\n%f\n\n\n布尔值\n%b\n\n\n字符\n%c\n\n\n字符串\n%s\n\n\n例:\n// 标志(flag) &quot;-&quot;, &quot;+&quot;, &quot;0&quot;, &quot;,&quot;// - :左对齐// + :输出正负符号// 0 :用0填充数字// , :数字大于1000, 用&quot;,&quot;隔开% &lt;标志&gt; &lt;精度&gt; &lt;宽度&gt; &lt;格式化类型&gt;// 字符串格式化System.out.printf(&quot;Hello %10s&quot;, &quot;this is format&quot;);\n\n\n关键字 finalfinal 关键字, 使其变量无法被更改\nfinal double pi = 3.14159;// final 关键字不能更改变量 pipi = 4;System.out.print(pi);\n\n\n面向对象 OOP1.大部分语言都要此功能, 可以去网上查查 ↩","categories":["Java"]},{"title":"JS-DOM","url":"/2022/JavaScript/js_dom/","content":"高级 DOM 操作\nDOM 概述DOM 是连接 js 和 浏览器 的接口\ngraph LRJS --- DOM --- Browser\n\n\n\nDOM 允许我们使用 js 与浏览器互动\n利用 js 增删改查 HTML 元素和属性, 以及 CSS 样式\nDOM 树基于 HTML 文件生成\nDOM 是一个非常复杂的 API\n\nAPI(Application Programming Interface)\n\nDOM API 的结构\n\n事件: 捕获和冒泡事件传播分三个阶段\n\n捕获\n目标\n冒泡\n\n\n事件监听器 .addEventListener() 默认只监听冒泡事件\n若要事件监听器捕获1事件, 需额外添加第三个参数 true :.addEventListener(&#39;事件&#39;, 回调函数, true)\n\n不同的方式载入 js 文件\n方法二和方法三仅适用于现代浏览器\n\n方法一常规加载方法html 会等待 js 脚本载入并执行完毕, 然后再载入和解析不建议使用该方法\n&lt;head&gt;  &lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;\n\n\n方法二不重要的代码可以使用该方法\n在加载 html 时同时, 也会加载 js (通过异步的方式)但 html 依旧需要等待 js 执行完成后进行解析\n该方法, 脚本的执行顺序不会依照代码上的声明顺序执行而是会依照先加载完的先执行这样的顺序执行\n&lt;head&gt;  &lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;\n\n\n方法三推荐使用重要的代码推荐使用该方法\n与上个方法不同的是, js 会在 html 解析完成后执行且会依照代码声明顺序执行\n&lt;head&gt;  &lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;\n1.捕获一般很少用 ↩","categories":["JavaScript"]},{"title":"Java基础语法-补充","url":"/2022/Java/java_basic_more/","content":"Java 基础操作-补充\ncase 语句例:\nint variable;switch (variable)&#123;case 1:    // 代码块    break;case 2:    // 代码块    break;...default:    //代码块&#125;\n\n错误处理异常捕获例:\ntry &#123;    // 可能发生错误的代码&#125;catch (Exception e)&#123;    // 发生异常执行的代码    // 输出异常信息    e.printStackTrace();&#125;finally &#123;    // 始终执行的代码块&#125;\n","categories":["Java"]},{"title":"Java面向对象编程","url":"/2022/Java/java_oop/","content":"对象对象的属性和方法对象都有:\n\n属性\n方法\n\n// 创建类(文件名: Car.java)public class Car &#123;    // 声明类属性    String make = &quot;Chevrolet&quot;;    String model = &quot;Corvette&quot;;    int year  =2020;    String color = &quot;blue&quot;;    double price = 50000.00;    // 声明类方法    void drive() &#123;        System.out.println(&quot;You drives the car&quot;);    &#125;    void brake() &#123;        System.out.println(&quot;You step on the brakes&quot;);    &#125;&#125;\n\n使用类:\nCar myCar = new Car();myCar.drive();\n\n\n类的构造函数作用是为一个类创建不同的实例\npublic class Human &#123;    String name;    int age;    double weight;    // 类的构造函数    // 用于创建不同的实例    Human(String name, int age, double weight)&#123;        this.name = name;        this.age = age;        this.weight = weight;    &#125;    // 访问对象属性    System.out.println(this.name+&quot; is eating&quot;);&#125;\n\nHuman human = new Human(&quot;Rick&quot;, 65, 70);\n\n\n重载构造函数在一个类里, 有多个名字相同的构造函数, 其区别在于, 其构造函数的传参不同\n\ntoString() 方法一个所有对象都继承的特殊方法toString 方法返回一个用文本表示对象的字符串\npublic class Car &#123;    String name = &#x27;test&#x27;;    int year = 2021;&#125;\n\nCar car = new Car();// 打印出来是： Car@36baf30c  (内存地址)system.out.println(car);// 需要重构toString() 方法// 如果不重构toString(), 返回的结果与上一个一样system.out.println(car.toString());\n\n重构 toString() 方法\npublic class Car &#123;    String name = &#x27;test&#x27;;    int year = 2021;    public String toString()&#123;        return name +  &quot;\\n&quot; + year    &#125;&#125;\n\n在列表中创建对象public class Food &#123;    String name;    Food(String name)&#123;        this.name = name;    &#125;&#125;Food newFood = new Food(&#x27;pizza&#x27;)// 创建对象列表Food[] test = new Food[3]// 将对象插入列表test[0] = newFood;// 另一种方法Food[] test = &#123;newFood, ..., ...&#125;\n\n\n将对象作为传参汽车类:\npublic class Car&#123;    String name;    Car(String name)&#123;        this.name = name;    &#125;&#125;\n\n停车场类:\npublic class Garage&#123;    void park(Car car)&#123;        system.out.println(&quot;The &quot;+car.name+&quot;is parked in the garage&quot;)    &#125;&#125;\n\n主函数:\n// 创建实例Garage garage = new Garage();Car car = new Car(&quot;BMW&quot;);//传入对象garage.park(car);\n\n\nstatic 关键字它是一个关键字修饰符可用于修饰 变量&#x2F;方法, 其类的对象共享 static 修饰的成员\n朋友类:\npublic class Friend&#123;    String name;    // static 修饰符    static int numberOfFriend = 0;    Friend(String name)&#123;        this.name = name;        numberOfFriend++;    &#125;&#125;\n\n主函数:\n// 输出0system.out.println(Friend.numberOfFriend);Friend friend1 = new Friend(&quot;Tom&quot;);Friend friend2 = new Friend(&quot;Jonas&quot;);// 输出2system.out.println(Friend.numberOfFriend);\n\nstatic 修饰的成员尽量以 类.成员 进行访问(静态访问)\n\njava 的继承利用 extends 关键字实现继承一个类能够获取其他类的属性和方法\n载具类:父类也被称为 super class\npublic class Vehicle&#123;    double speed;    void go()&#123;        System.out.println(&quot;这辆车在移动&quot;);    &#125;    void stop() &#123;        System.out.println(&quot;现在刹车&quot;);    &#125;&#125;\n\n\n继承类 ↓\n汽车类:\npublic class Car extends Vehicle&#123;    int wheel = 4;    int doors = 4;&#125;\n\n自行车类:\npublic class Bicycle extends Vehicle&#123;    int wheel = 2;    int pedals = 2;&#125;\n\n\n主函数:\nCar car = new Car();Bicycle bicycle = new Bicycle();// 继承并调用父类方法car.go();System.out.println(car.doors);System.out.println(bicycle.pedals);\n\n\njava 继承的方法重写在父类中定义一个方法, 子类可以对其进行重写以使子类拥有其自己独有的方法\n动物类(父类):\npublic class Animal&#123;    void speak()&#123;        System.out.println(&quot;The animal speak&quot;);    &#125;&#125;\n\n狗类(子类):\npublic class Dog extends Animal&#123;    // 子类方法重写    // @Override并非必须, 只是告诉其他人这是方法重写    @Override    void speak()&#123;        System.out.println(&quot;The dog goes bark&quot;);    &#125;&#125;\n\n\n主函数:\nDog dog = new Dog();dog.speak();\n\n\njava 的 super 关键字类似于 this 关键字super: 一个引用父类的关键字\n人类(父类):\npublic class Person&#123;    String name;    int age;    Person(String name, int age)&#123;        this.name = name;        this.age = age;    &#125;    public String toString()&#123;        return this.name + &#x27;\\n&#x27; +  this.age;    &#125;&#125;\n\nsuper(), 用于继承(使用)父类构造方法super.方法, 用于继承(使用)父类方法\n英雄类(子类):\npublic class Hero extends Person&#123;    String power;    // 使用super()方法继承构造函数    Hero(String name, int age, String power)&#123;        super(name, age);        this.power = power;    &#125;    public String toString()&#123;        // super关键字调用父类方法        return super.toString() + this.power;    &#125;&#125;\n\n\n主函数:\nHero hero1 = new Hero(&quot;Batman&quot;, 42, &quot;rich&quot;);System.out.println(hero1.name);System.out.println(hero1.age);System.out.println(hero1.power);System.out.println(hero1.toString());\n\n\nabstract 关键字(抽象类)抽象类不能被实例化, 但是它们可以拥有一个没有代码块的子类抽象方法\n载具类(父类):\n由于载具类过于抽象(载具可以指飞机, 坦克, 船,等等…)所以可以使用 abstract 关键字(可以提高程序安全性)\npublic abstract class Vehicle&#123;    // 抽象方法    // 强制用户在子类声明具体方法    abstract void go();&#125;\n\n汽车类(子类):\npublic class Car extends Vehicle&#123;    @Override    void go()&#123;        System.out.println(&quot;司机在开汽车&quot;);    &#125;&#125;\n\n\n主函数:\nCar car = new Car();car.go();\n\n\n访问权限关键字访问权限关键字用于增强程序安全性\n\npublic\nprotect\nprivate\n\npackage 是类的集合 , class是代码的集合\n\n\n\n关键字\n类\n包\n子类\n全局\n\n\n\npublic\nY\nY\nY\nY\n\n\nprotected\nY\nY\nY\nN\n\n\n无\nY\nY\nN\nN\n\n\nprivate\nY\nN\nN\nN\n\n\n全局指: 不同的包之间可以进行访问包指: 可以访问当前的包子类指: 无论是不同的包还是类; 只要是其子类, 就可以访问类指: 只能访问本类自身\n\n在 package1 下的 A.java 和 B.java\nA.java:\npackage package1;import package2.*;public class A&#123;    protected String protectMessage = &quot;这是 protected&quot;;    public static void main(String[] args)&#123;        C c = new C();        // public 全局(如何包)都可以访问        System.out.println(C.publicMessage)    &#125;&#125;\n\nB.java:\npackage package1;import package2.*;public class B&#123;&#125;\n\n\n在 package2 下的 Asub.java 和 C.java\nAsub.java:Asub 类是 A 类的子类\npackage package2;// 为继承A类的所有内容, 需要用到 importimport package1.*;public class Asub extends A&#123;    public static void main(String[] args)&#123;        C c = new C();        Asub asub = new Asub();        // 默认访问权限: 在同一个包内, 可以访问        System.out.println(C.defaultMessage)        // protected 访问权限, 子类可以访问父类        System.out.println(asub.protectedMessage)    &#125;&#125;\n\nC.java:\npackage package2;import package1.*;public class C&#123;    public String publicMessage = &quot;这是 public &quot;;    protected String protectedMessage = &quot;这是 protected&quot;;    String defaultMessage = &quot;这是默认的访问权限&quot;;    private privateMessage = &quot;这是 private&quot;;&#125;\n\n\njava 的封装一个可以将类隐藏或转为私有的类属性封装的类属性只能通过方法 getter 和 setter 访问\n依旧是提高程序安全性, 似乎一般用不到\n车类:\npublic class Car&#123;    private String make;    private String model;    private int year;    Car(String make, String model, int year)&#123;        // 为避免代码重复, 当声明了setter方法, 可以在构造函数中调用其setter        this.setMake(make);        this.model = model;        this.year = year;    &#125;    // get方法    public String getMake() &#123;        return make;    &#125;    // set方法    public String setMake(String make)&#123;        this.make = make;    &#125;&#125;\n\n主函数:\nCar car = new Car(&quot;Chevrolet&quot;, &quot;Camaro&quot;, 2021);System.out.println(car.getMake());System.out.println(car.setMake(&quot;BMW&quot;));\n\n\n复制对象通过再次构造实例化对象, 实现对象复制(内存地址不同)\n// java 封装的示例代码基础上添加// 在Car类添加以下代码public void copy(Car x)&#123;    this.setMake(x.getMake())    ...&#125;\n\njava 接口接口是可以应用于类的模板, 类似于继承但是接口指定类必须做什么\n类只能继承一个父类, 但类可以有多个接口\n猎物接口:\npublic interface Prey&#123;    // 可以在接口中声明方法和属性    // 不同的是, 方法不能指明代码块    void flee();&#125;\n\n捕食者接口:\npublic interface Predator&#123;    void hunt();&#125;\n\n\n兔子类:\npublic class Rabbit implements Prey&#123;    // 就行抽象方法一样    void flee()&#123;        System.out.println(&quot;兔子在逃跑&quot;)    &#125;&#125;\n\n鹰类:\npublic class Hawk implements Predators&#123;    void hunt()&#123;         System.out.println(&quot;老鹰在捕猎&quot;)    &#125;&#125;\n\n鱼类:可以是捕猎者, 也可以是猎物\npublic class Fish implements Predator, Prey&#123;    @Override    void hunt() &#123;        System.out.println(&quot;大鱼吃小鱼&quot;);    &#125;    @Override    void flee() &#123;        System.out.println(&quot;小鱼被大鱼吃&quot;);    &#125;&#125;\n\njava 的多态性多态性指: 识别一个拥有多个类型的对象的能力\n载具类(父类):\npublic class Vehicle&#123;    public void go()&#123;    &#125;&#125;\n\n车类:\npublic class Car extends Vehicle&#123;    @Override    public void go()&#123;        System.out.println(&quot;开车!!!&quot;)    &#125;&#125;\n\n自行车类:\npublic class Bicycle extends Vehicle&#123;    @Override    public void go()&#123;        System.out.println(&quot;骑车!!!&quot;)    &#125;&#125;\n\n船类:\npublic class Boat extends Vehicle&#123;    @Override    public void go()&#123;        System.out.println(&quot;开船!!!&quot;)    &#125;&#125;\n\n\n主函数:\nCar car = new Car();Bicycle bicycle = new Bicycle();Boat boat = new Boat();// 利用多态性, 将对象存入列表Vehicle[] racers = &#123;car, bicycle, boat&#125;;// 循环调用对象方法for(Vehicle x : racers) &#123;    x.go();&#125;\n\n\n动态的多态性","categories":["Java"]},{"title":"模态窗口","url":"/2022/JavaScript/js_modal_window/","content":"平滑滚动section1.scrollIntoView(&#123; behavior: &#x27;smooth&#x27; &#125;);\n","categories":["JavaScript"]},{"title":"Markdown 数学公式","url":"/2022/Markdown/markdown_math/","content":"数学符号\n\n\n代码\n符号\n描述\n\n\n\n\\not=\n\n不等于\n\n\n\\approx\n\n约等于\n\n\n\\leq\n\n大于等于\n\n\n\\geq\n\n小于等于\n\n\n\\times\n\n乘\n\n\n\\div\n\n除\n\n\n分数用 \\frac{}{} 表示分数\n例:\n$ \\frac{a}{b} $\n\n\n向量例:\n\n\\vec A = \\vec{AB}\n\n\n","categories":["Markdown"]},{"title":"php基础","url":"/2022/php/php_basic/","content":"php 语法\n数组php 有三个类型的数组:\n\n数值数值(下标为数字)\n关联数组(下标为字符串)\n多维数组\n\n数值数组, 例:\n// 声明数值数组:$fruits = array(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);// 数组调用:echo &quot;I like&quot; .  $fruit[2] . &quot;!&quot;;\n\n\n声明关联数组, 例:\n$age = array(&quot;Tom&quot; =&gt; &quot;18&quot;, &quot;Jonas&quot; =&gt; &quot;45&quot;, &quot;me&quot; =&gt; &quot;unknown&quot;);echo &quot;Tom is &quot; . $age[&quot;Tom&quot;] . &quot; years old~&quot;;\n\n\n关联数组循环利用 foreach() 循环关联数组:\nforeach($age as $i =&gt; $i_value)&#123;    echo $i . &quot;\\&#x27;s age is: &quot; . $i_value;    echo &quot;&lt;br&gt;&quot;;&#125;\n\n\n获取数组长度利用 count(数组) 获取数组长度\n$length = count($fruits);echo &quot;这是数组长度: &quot; . $length;\n\n\n循环foreach 循环\n\n\n函数\nswitch 语句switch (n)&#123;case 参数:    // 代码块    break;case 参数    // 代码块    break;default:    // 都不匹配执行的代码&#125;\n\n\n数据库操作数据库链接// 例:$db_connect = mysqli_connect(&#x27;数据库地址&#x27;, &#x27;用户名&#x27;, &#x27;密码&#x27;, &#x27;库名&#x27;, &#x27;数据库端口&#x27;);// 实例$link = mysqli_connect(&#x27;localhost&#x27;, &#x27;root&#x27;, &#x27;&#x27;, &#x27;my_project&#x27;, &#x27;3306&#x27;);\n","categories":["php"]},{"title":"基于Python的算法学习","url":"/2023/Python/python_algorithm/","content":"基础时间复杂度一种表示算法快慢的方式是用来估计算法运行时间的一个式子(单位)\n一般来说, 时间复杂度高的算法比时间复杂度低的算法慢\n\n常见的时间复杂度:\n复杂问题的时间复杂度:\n\n\n\n一行代码的时间复杂度1 : \n一个 for 循环时间复杂度为: \n两层循环时间复杂度: \n\n\n例:\n时间复杂度为  的代码\nfor i in range(n):    for j in range(n):        print(\"Hello~\")\n\n时间复杂度为  的代码\n\nwhile n &gt; 1:    print(n)    n = n // 2\n\n简单来说, 当算法过程出现循环折半的时候时间复杂度就会出现 \n\n简单判断时间复杂度绝大多数简单情况:\n\n确定问题规模 n\n循环过程减半 \nk 层关于 n 的循环 \n\n\n空间复杂度用于评估算法内存占用的式子空间复杂度的表示方式与时间复杂度完成一样\n\n算法使用了几个变量: \n算法使用了长度为 n 的一维列表: \n算法使用了 m 行 n 列的二维列表: \n\n在算法中, 时间远比空间重要因此, 大多算法常采用 “时间换空间” 的做法\n\n递归递归的特点:\n\n调用自身\n有结束条件\n\n\n例:\ndef go(x: int):    if x &gt; 0:        print(x)        go(x - 1)# 输出go(3)&gt;&gt;&gt;3&gt;&gt;&gt;2&gt;&gt;&gt;1\n\ndef go(x: int):    if x &gt; 0:        go(x - 1)        print(x)# 输出go(3)&gt;&gt;&gt;1&gt;&gt;&gt;2&gt;&gt;&gt;3\n\n\n汉诺塔著名的递归问题, 具体内容自己网上查\n\n当有 n 个盘子时:\n\n把 n-1 个盘子从 A 经过 C 移动到 B\n把 n 个盘子从 A 移动到 C\n把 n-1 个小圆盘经过 A 移动到 C\n\ndef hanoi(n, a, b, c):    '''    参数a, b, c 分别对应a柱, b柱, c柱    '''    # 当a柱有盘子时, 结束    if n &gt; 0:        # 把 A 经过 C 移动到 B        hanoi(n-1, a, c, b)        print(f\"把{a}移动到{c}上\")        # 把 B 经过 A 移动到 C        hanoi(n-1, b, a, c)# 调用函数hanoi(3, \"A\", \"B\", \"C\")\n\n\n查找查找: 在一些数据元素中通过一定的方法找出与给定关键字相同的数据元素的过程\n列表查找(线性表查找): 从列表中查找指定元素\n\n顺序查找也称线性查找, 从列表的第一个元素开始顺序进行搜索, 直到找到元素或搜索到列表最后一个元素为止\n例:\n# for ... else ... 语句def linear_search():    for i, e in enumerate(li):        if e == value:            return e    else:        return -1\n\n\n二分查找二分查找仅适用于有序列表\n又称折半查找, 从有序列表的初始候选区 li[0:n] 开始通过对待查找的值与候选区中间值的比较, 可以使候选区减少一半\n例:\ndef binary_search(value, li: list) -&gt; int:    left = 0    right = len(li) - 1    while left &lt; right:        mid = (left + right) // 2        if li[mid] == value:            return mid        elif li[mid] &gt; value:            right = mid - 1        else:            left = mid + 1    else:        return -1\n\n\n排序将一组无序的记录序列调整为有序的记录序列\n简单的排序:\n\n冒泡排序\n选择排序\n插入排序\n\n复杂的排序:\n\n快速排序\n堆排序\n归并排序\n\n冒泡排序过于简单, 不予介绍\n例:\ndef bubble_sort(li: list):    for i in range(len(li) - 1):        for j in range(len(li)-i-1):            if li[j] &gt; li[j+1]:                li[j], li[j+1] = li[j+1], li[j]\n\n时间复杂度: \n\n改进代码:\n如果在冒泡排序过程中二层循环没有发生冒泡, 就说明列表已经排序完成可以直接终止循环\ndef bubble_sort(li: list):    for i in range(len(li) - 1):        exchange = False        for j in range(len(li)-i-1):            if li[j] &gt; li[j+1]:                li[j], li[j+1] = li[j+1], li[j]                exchange = True        if not exchange:            return\n\n\n选择排序简单的选择排序遍历一遍列表, 将最小的数添加进新列表然后删除旧列表中的最小数\ndef select_sort_simple():    new_li = []    for i in range(len(li)):        min_val = min(li)        new_li.append(min_val)        li.remove(min_val)    return new_li\n\nmin(li) 和 li.remove(min_val) 的时间复杂度为 该代码的时间复杂度为: 该算法空间复杂度较大, 不推荐使用\n\n改进的选择排序相较于冒泡排序, 这一算法的交换次数会较少一点\n原理:第一层循环为有序区的起始位置第二层循环找到最小的数的位置, 并将最小数移动到有序区\ndef select_sort(li):    for i in range(len(li)-1):        min_loc = i        for j in range(i+1, len(li)):            if li[j] &lt; li[min_loc]:                min_loc = j        li[i], li[min_loc] = li[min_loc], li[i]\n\n\n插入排序原理:第一层循环为无序区第二层循环, 判断插入元素大小按要求移动有序区元素, 然后将元素有序的插入有序区\ntmp 为插入的元素i 为无序区的起始位置j 为有序区的结束位置\ndef insert_sort(li):    for i in range(1, len(li)):        tmp = li[i]        j = i - 1        while tmp &lt; li[j] and j&gt;= 0:            li[j+1] = li[j]            j -= 1        li[j+1] = tmp\n\n时间复杂度: \n\n快速排序原理:\n\n取一个元素 p(第一个元素), 使元素 p 归位\n归位: 列表 p 分为两部分, 左边比 p 小, 右边比 p 大\n递归完成排序\n\n# 排序前:[5, 7, 4, 6, 3, 1, 2, 9, 8]# p 归位:[2, 1, 4, 3, 5, 6, 7, 9, 8]# 结束:[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n代码:\ndef partition(li, left, right):    tmp = li[left]    while left &lt; right:        while left &lt; right and li[right] &gt;= tmp:            right -= 1        li[left] = li[right]        while left &lt; right and li[left] &lt;= tmp:            left += 1        li [right] = li[left]    li[left] = tmp    return left\n\ndef quick_sort(li, left, right):    if left &lt; right:        mid = partition(li, left, right)        quick_sort(li, left, mid-1)        quick_sort(li, mid+1, right)\n\n由于 python 有着递归深度限制, 默认为 1000所以上述代码在排序较大的列表时, 会引发 maximum recursion depth exceeded in comparison 报错不建议使用太深的递归算法\n在最坏的情况下(即倒序的列表), 时间复杂的为 \n\n堆排序1. 是一个单位 ↩","categories":["Python"]},{"title":"Python 异步(协程) 与 并发","url":"/2023/Python/python_async/","content":"并发概念程序提速方法:\n\n单线程串行\n多线程并发 threading 模块\n多 CPU 并行 multiprocessing 模块\n多机器并行 hadoop/hive/spark 模块\n\n\n异步python 协程概念单线程智能的去切换执行程序\n实现协程的方法:\n\n通过第三方模块\nyield 关键字\nasyncio 模块1 (python &gt;&#x3D; 3.4)\nasync/await 关键字 (python &gt;&#x3D; 3.5) 推荐\n\n事件循环在事件循环中, 会去检测并执行事件循环内的代码(事件)\n每个事件拥有两个状态:\n\n可执行\n已完成\n\n事件循环会对其事件的状态进行处理, 当处理完所有事件后, 事件循环将会停止\n# 任务列表tasks = [任务1, 任务2, 任务3]\n\n# 生成一个事件循环loop = asyncio.get_event_loop()# 将任务任务列表放入事件循环loop.run_until_complete(tasks)\n\npython 异步编程async 关键字\n协程函数 async def func():\n协程对象 func()\n\n当执行协程函数时, 会返回一个协程对象协程函数内的代码不会被执行\n要想运行协程函数的内部代码, 还需要使用事件循环 和 任务列表2\n# 定义协程函数async def func():    pass# 执行协程函数得到 协程对象# 协程对象 resultresult = func()\n\n事件循环的老写法:\nasync def func():    print(&quot;这是协程函数内的代码&quot;)# python &lt;= 3.7 的写法# 执行事件循环中的事件result = func()loop = asyncio.get_event_loop()loop.run_until_complete(result)\n\n新写法:\nasync def func():    print(&quot;这是协程函数内的代码&quot;)# 现代写法result = func()asyncio.run(result)# asyncio.run(result) 等价于:# loop = asyncio.get_event_loop()# loop.run_until_complete(result)\n\n\nawait 关键字await: 异步等待 (asynchronous wait)\n在 python 中, 有 3 种可等待对象:\n\n协程对象 Coroutine\nFuture\nTask 对象\n\n# 使用方法await 可等待对象\n\n代码实例:\nawait 可以执行 协程对象\n先执行所有代码, await 可等待对象 会执行操作并挂起事件循环会一直等待当可等待对象完成操作后, 事件循环将切换并执行下一个代码(可以简单认为 await 相当于回调)\n以下代码均为同步代码 ↓\nimport asyncioasync def asy_test():    print(&quot;测试测试&quot;)    await asyncio.sleep(4)    print(&quot;结束的阻塞代码&quot;)asyncio.run(asy_test())\n\n\nTask 对象用于在事件循环中添加多个任务\n通过 asyncio.create_task(协程对象) 创建 Task 对象3然后协程对象会加入事件列表中等待被事件循环调度执行\n与 协程对象 不同的是, 事件循环会切换执行 Task 对象\n不常用的实例:\n异步代码 ↓\nasync def func():    print(&quot;开头&quot;)    await asyncio.sleep(3)    print(&quot;结尾&quot;)# 最终程序耗时3秒async def main():    print(&quot;主程序开始...&quot;)    # 创建Task对象    task1 = asyncio.create_task(func())    task2 = asyncio.create_task(func())    print(&quot;Task对象创建结束&quot;)    ret1 = await task1    ret2 = await task2    print(&quot;最终值: &quot;, ret1, ret2)asyncio.run(main())\n\n常用的实例:\n# 改造上面的代码 ↑#   asyncio.create_task(协程对象, name=&quot;任务名称&quot;)task_li = [    asyncio.create_task(func(), name=&quot;任务1&quot;),    asyncio.create_task(func(), name=&quot;任务2&quot;)]# asyncio.wait(任务列表, timeout)# timeout 设置时间限制 (默认time=None, 等待时间无限制)# 将列表中的所有任务进行 await# 返回元组 (done, pending)# done: 返回集合# pending: 未完成的任务await asyncio.wait(task_li)\n\n\nFuture 对象 (asyncio)不常用的底层对象 Task对象 的基类Task 继承 Future, Task 内部结果的处理基于 Future\nasync def main():    # 获取事件循环    loop = asyncio.get_event_loop()    # 创建Future对象, 不做任何事    future = loop.create_future()    # 等待任务结果, 但由于没有做如何事    # 该代码会一直等下去    await futureasyncio.run(main())\n\n另一个实例:\nasync def set_after(future):    await asyncio.sleep(2)    # 手动设置 Future 任务的最终结果    future.set_result()async def main():    loop = asyncio.get_event_loop()    future = loop.create_future()    await loop.create_task(set_after(future))    data = await future    print(data)asyncio.run(main())\n\n\nasyncio 异步迭代器迭代器: 实现 __iter__() 和 __next__ 方法的对象\n异步迭代器: __anext__ 方法必须返回一个可等待对象.async for 会处理异步迭代器的 __anext__() 方法所返回的可等待对象,直到其引发一个 StopAsyncIteration 异常\n....\n\n\n异步上下文管理器此种对象通过定义 __aenter__() 和 __aexit__() 方法对 async with 语句的环境进行控制\n上下文管理器: with\n...\n\n\nuvloop简单理解为是异步事件循环的替代方案通过第三方实现, uvloop 事件循环要优于默认 asyncio 的事件循环\nuvloop 性能更好\npip install uvloop\n\n\n代码示例asyncio 模块异步编程import asyncio# 协程函数(老写法, python&gt;=3.8已弃用)@asyncio.coroutinedef func1():    print(1)    # 模拟IO操作    # 当遇到消耗大量时间的IO操作时    # 线程会切换执行其他任务    yield from asyncio.sleep(2)    print(2)# 现代写法async def func2():    print(3)    await asyncio.sleep(2)    print(4)# 事件列表tasks = [    asyncio.ensure_future(func1()),    asyncio.ensure_future(func2())]# 遇到IO自动切换loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))\n\n最终输出结果:\n&gt;&gt;&gt;1&gt;&gt;&gt;3&gt;&gt;&gt;2&gt;&gt;&gt;4\n\n\nasync&#x2F;await 协程async 和 await 原理与 asyncio 模块的实现方法一致区别仅在于代码的简洁性\nimport asyncioasync def func1():    print(1)    # 模拟IO操作    await asyncio.sleep(2)    print(2)async def func2():    print(3)    await asyncio.sleep(2)    print(4)# 事件列表tasks = [    asyncio.ensure_future(func1()),    asyncio.ensure_future(func2())]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))\n\n最终输出结果:\n&gt;&gt;&gt;1&gt;&gt;&gt;3&gt;&gt;&gt;2&gt;&gt;&gt;4\n\n\nyiled 关键字了解即可\nyiled 返回数据\ndef func1():    yield 1    yield from func2()    yield 2def func2():    yield 3    yield 4f1 = func1()for item in f1:    print(item)\n\n最终输出结果:\n&gt;&gt;&gt;1&gt;&gt;&gt;3&gt;&gt;&gt;4&gt;&gt;&gt;2\n\n\ngreenlet 协程form greenlet import greenletdef func1():    print(&quot;1&quot;)    # 切换执行函数2    gr2.switch()    print(&quot;2&quot;)    gr2.switch()def func2():    print(&quot;3&quot;)    gr1.switch()    print(&quot;4&quot;)# 生成?gr1 = greenlet(func1())gr2 = greenlet(func2())# 执行函数1gr1.switch()\n\n最终输出结果:\n&gt;&gt;&gt;1&gt;&gt;&gt;3&gt;&gt;&gt;2&gt;&gt;&gt;4\n\n\n异步与阻塞混用案例: asyncio + 不支持异步的模块但需要多线程的编程知识, 暂时不管\n简单来讲, 如果是单线程, asyncio + 不支持异步的模块是难以做到异步的\n...\n\n\n1.python 标准库 ↩2.任务列表, 实现异步的关键 ↩3.还可以通过 asyncio.ensure_future()创建 Task (python &lt;= 3.7) ↩","categories":["Python"]},{"title":"Python 语法","url":"/2023/Python/python_basic/","content":"字符串操作反转字符串直接使用切片反转\nletters = &quot;ABCDEFG&quot;# 反转letters = letters[::-1]print(letters)&gt;&gt;&gt;GFEDCBA\n\n\n错误处理try 语句try:    # 可能报错的代码except &lt;错误1&gt;:    # 错误处理1except &lt;错误2&gt; as &lt;错误参数&gt;:    # 错误处理2else:    # 如果无异常发生, 则执行该段代码finally:    # 无论如何都会执行的代码\n\n\nraise除了错误处理, 我们还可以手动抛出错误\nimport httpxasync def get_test():    try:        with AsyncClient() as client:            client.get(&quot;http://www.baidu.com&quot;)    except httpx.TimeoutException as e:        print(&quot;请求超时&quot;)        raise e\n\n除此之外, 还可以自定义异常\n# 自定义异常类 继承 异常基类class MyException(Exception):    def __init__(self, error_info):        self.error_info = error_info    def __str__(self):        return self.error_info\n\n# 手动抛出自定义错误try:    raise CustomException(&quot;自定义异常名称&quot;)except CustomException as e:    print(e)\n\n\nwith 语句with 语句是 try... 错误处理语句的封装\ntry 语句写法:\nfile = open(&#x27;./temp_text.txt&#x27;, &#x27;w&#x27;)try:    file.write(&#x27;写进一些字符...&#x27;)finally:    file.close()\n\nwith 语句写法:\nwith 语句会通过上下文管理器自动调用相关方法在文件操作中, with 会自动调用 file.close() 方法\nwith open(&#x27;./test_runoob.txt&#x27;, &#x27;w&#x27;) as file:    file.write(&#x27;hello world !&#x27;)# 查看文件是否被关闭print(file.closed)\n\n\n内置函数enumerate()将一个可遍历的数据对象组合为一个索引序列, 同时列出数据和数据下标\n# start= 下标起始位置enumerate(可迭代对象, start=0)\n\n例:\nli = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]for i, element in li:    print(i, element)\n\n\nbin()bin(整型)\n返回二进制表示的字符串\nnum = bin(10)print(num)&gt;&gt;&gt;0b1010\n\n\nmap()map(函数名, 可迭代对象)\n指定处理函数, 用于处理可迭代对象内的每个元素函数返回一个 map 对象\n例:将列表内的每个元素向下取整\nli = [1.2, 5.6, 3.3, 9.7, 8.8]# 将 map 对象转换为列表li = list(map(int, li))\n\n\n\n列表操作index()\npython 特殊变量, 方法__方法名__, __变量名__ 是 python 的特殊方法或特殊变量\n特殊变量__file____file__ 储存的是当前 python 脚本的运行路径\n需要注意的是:如果执行文件是使用的相对命令, 那么 __file__ 储存的就是相对路径反之, 储存的则是绝对路径\n\n特殊方法__str__()__str__() 方法用于类\n\n当不定义 __str__方法时python 输出对象时即 print(对象) 时, 默认输出其实例内存地址\n当定义 __str__方法时, 自动调用该方法\n\n注意: __str__() 方法的返回值必须为字符串\n\n例:\nclass Test:    def __init__(self):        self.name = &quot;测试对象&quot;    def __str__(self):        return self.nametest = Test()print(test)&gt;&gt;&gt;&quot;测试对象&quot;\n\n\n__import__()用于动态导入模块如果一个包经常变化就可以使用 __import__() 动态载入模块\n但是, 这个方法是给 python 解析器内部使用的官方不建议使用该特殊方法官方建议使用 importlib 动态导入模块\n__import__(模块) 相当于 import 模块\n# 加载模块sys = __import__(&#x27;sys&#x27;)# 相对加载包内模块example = __import__(&#x27;.example&#x27;)\n\n另一个例子:\n# 导入包内子模块# 加入传参 fromlistexample = __import__(&#x27;os&#x27;, fromlist=[&quot;path&quot;, &quot;platform&quot;])\n","categories":["Python"]},{"title":"Python 位运算","url":"/2023/Python/python_bitwise/","content":"逻辑与位运算符位运算共两大类\n\n逻辑位运算符\n位与 &amp; — AND\n位或 | — OR\n异或 ^ — NOT\n按位取反 ~ — NAND\n\n\n位移运算符\n左移 &lt;&lt;\n右移 &gt;&gt;\n\n\n\n\n逻辑运算符位与 &amp;位与是一个二元运算符\n当两个数都为 1 时结果为 1, 否则为 0\n\n例:\n十进制\n\n转换为二进制:\n\n1000 的十进制为 8\n\n位或 |两个数都为 0 时结果才为 0, 否则为 1\n\n例:\n\n二进制:\n\n\n异或 ^两个数不同时结果才为 1, 否则为 0\n\n例:\n\n二进制:\n\n\n按位取反 ~将每个二进制取反, 1 变为 0, 0 变为 1\n\n例:\n\n~12 = -13\n\n二进制(8 位):\n\n~0000 1100 = 1111 0011\n\n\n位移运算符左移每个二进制位左移若干位, 高位丢弃, 低位补 0\n\n右移每个二进制位右移若干位, 低丢弃, 高位补 0\n\n计算机符号数计算机符号数有 3 种表示方式\n\n原码\n反码\n补码\n\n后面慢慢写\n源码\n反码\n补码\n","categories":["Python"]},{"title":"Python 标准库","url":"/2023/Python/python_statnder/","content":"datetime# 导入模块from datetime import datetime\n\n\n获取和设置时间from datetime import datetime# 获取当前时间now = datetime.now()# 设置时间set_now = datetime(2023, 1, 3)\n\n\n一年的周数from datetime import datetimeset_now = datetime(2023, 1, 3)# .isocalendar()返回 (年, 当前周数, 星期)current_week = set_now.isocalendar()# 结果: (2023, 1, 2)\n\n\ncalendarimport calendar\n\n计算每个月的天数monthrange(年, 月)函数返回一个元组 (星期数, 天数)\n注: 星期数为 0~6\nresult = calendar.monthrange(2022, 2)print(result)&gt;&gt;&gt;(1, 28)\n\n\npathlib一般对于系统路径的方法使用的模块是 os.path 模块os.path 模块处理不同操作系统的路径时, 可能还需要修改代码因此推荐路径操作使用 pathlib\nimport pathlib\n\n…\nsys修改递归最大深度import syssys.setrecursionlimit(1000)\n","categories":["Python"]},{"title":"Python 第三方库","url":"/2023/Python/python_lib/","content":"bs4 库bs4: 网页数据抓取库\nimport bs4\n\nBeautifulSoup 对象构造参数:\nBeautifulSoup(html文本, 解析器)\n\n\n\n解析器\n构造传参\n特点\n\n\n\npython 标准库\n(html, “html.parser”)\n速度中, 容错强\n\n\nlxml HTMl\n(html, “lxml”)\n速度快, 容错强\n\n\nlxml XML\n(html, [“lxml”, “xml”])\n速度快, 支持 xml 解析\n\n\nhtml5lib\n(html, “html5lib”)\n以浏览器的方式解析文档, 生成 html5 文档\n\n\n\n对象属性\nname: 标签名\n\n\n对象方法find_all()搜索当前 tag 的所有 tag 子节点返回符合条件的结果集 bs4.Element.ResultSet\n当循环结果集时, 每个结果为一个字典\ntags = html.find_all(&quot;div&quot;)for element in tags:    print(type(element))\n\nfind()find(&quot;title&quot;) 等价于 find_all(&quot;title&quot;, limit=1)\n返回一个页面元素\n","categories":["Python"]},{"title":"Python 包和模块","url":"/2023/Python/python_pakge_module/","content":"概念\n模块\n简单来讲, 模块是单独的 py 文件\n\n\n包\n一个有层次的文件命令结构, 内部可以包含多个模块和子包\n\n\n库\n完成一定功能代码的集合\n可以是模块, 也可以是包\n\n\n\n包和模块创建模块就是 .py 文件\n包的创建, 需要在目录中创建一个名为 __init__.py 文件1一般都建议创建 __init__.py 文件\n__init__.py作用:\n\n导入包的时候, 会自动执行 __init__.py可以做一些包的预操作\n导入子包\n\n# 导入包内模块.模块名\n\n\n\n\n信息dir() 方法, 返回模块拥有的 API, 具体细节网上查\n__file__ 特殊变量, 储存的是模块的绝对路径\n获取模块信息, 例:\nimport os# 模块绝对路径print(os.__file__)# 查看模块的APIprint(dir(os))\n\n\n导入模块导入的方法并不存在内存消耗的区别\n模块导入时, 有其检索顺序\n\n第一次导入\n第一级, 按内置模块顺序检索\n第二级\n按 sys.path, 路径列表\n追加路径, …\n\n\n\n\n第二次导入\n\n追加路径:\nimport sys# 将路径追加至路径列表sys.path.append(&quot;C:\\\\Desktop\\\\example\\\\&quot;)\n\n常规导入模块导入\n# 导入单个模块import &lt;模块名&gt;# 导入多个模块import &lt;模块1&gt;, &lt;模块2&gt;# 将模块指向变量import &lt;模块&gt; as &lt;变量名&gt;\n\n包内模块导入\nimport &lt;包名&gt;.&lt;模块名&gt;...\n\n\nfrom 语句from &lt;模块名&gt; import &lt;模块API&gt;\n\n\n导入场景局部导入# os模块仅属于函数内的命名空间def example():    import os# 函数外无法访问print(os.path)\n\n循环导入在模块 A 导入了模块 B又在模块 B 中导入模块 A引起循环导入\n注: import 语句只会运行一次\n\n可选导入会遇到两个功能相近的包, 想要有个备选包例如: request 库和 aiohttp 库\ntry:    import &lt;包1&gt;except ModuleNotFoundError:    import &lt;包2&gt;# 或try:    import &lt;包1&gt; as baoexcept ModuleNotFoundError:    import &lt;包2&gt; as bao\n\n\n包内导入包内导入分绝对导入2和相对导入\n\n绝对导入:通过路径列表导入\n相对导入:通过 . 指代相对路径\n\n绝对导入:\n# 例import osfrom os import path\n\n相对导入:\n# &quot;.&quot; 当前目录# &quot;..&quot; 上级目录import .my_modulefrom .my_module import method\n1.python 版本 &gt;= 3.3 可以不创建 ↩2.适用于 python &gt;= 3.0 ↩","categories":["Python"]},{"title":"RabbitMQ","url":"/2023/OpenStack/rabbitmq/","content":"工作流程graph LRexchanger[交换机] -.-路由键-.-&gt; queue[队列]queue --绑定键--&gt; exchanger\n\ngraph LR    subgraph one    producer1((生产者1))    producer2((生产者2))    producer3((生产者3))    endproducer1 --路由键--&gt; exchanger1producer2 --路由键--&gt; exchanger2producer3 --路由键--&gt; exchanger1    subgraph RabbitMQ Broker    exchanger1[交换机1] --&gt; queue1    exchanger1[交换机1] --&gt; queue3    exchanger2[交换机2] --&gt; queue2    exchanger2[交换机2] --&gt; queue4    endqueue1[队列1] --&gt; consumer1queue2[队列2] --&gt; consumer2queue3[队列3] --&gt; consumer1queue4[队列4] --&gt; consumer1    subgraph 消费者    consumer1((消费者1))    consumer2((消费者2))    end\n\nRabbitMQ Broker: 消息中间件的服务节点\n信息交换机类型\n定义\n优缺点\n适用场景\n如何应用\n\nFanout(扇形)交换机就像交换机一样, 广播消息\n\n将所有信息绑定到消息队列\n与该交互机绑定的, 都会收到其交货机的广播消息\n\n定义Fanout 交换机将消息广播到与其绑定的所有队列。无视消息的路由键，适合广播消息的场景。\n优缺点\n优点\n\n可以将消息广播到所有与之绑定的队列，适用于需要广播消息的场景，比如日志系统、发布订阅系统等\n\n\n缺点\n\n不能进行精确的路由控制，不适用于需要特定路由规则的场景\n\n\n\n适用场景举例:例如，在一个多播聊天室中，当一个用户发送一条消息时，所有其他用户都应该接收到这条消息。在这种情况下，可以使用 Fanout 交换机将消息广播到所有与之绑定的队列中\n\nTopic(主题)交换机定义Topic 交换机根据消息的路由键将消息路由到与之匹配的队列中。路由键可以使用通配符进行匹配，适合处理一对多的消息发送场景。\n优缺点\n优点\n可以根据消息的路由键进行精确的路由控制，只将消息发送到与之完全匹配的队列中，适用于需要一对一的消息发送场景\n\n\n缺点\n路由键只能使用固定的字符串，不支持通配符匹配\n\n\n\n适用场景举例:例如，在一个电商系统中，当一个用户购买一件商品时，需要根据商品的类别和品牌将订单信息发送到特定的队列中，以便相关的部门进行处理。在这种情况下，可以使用 Topic 交换机根据商品的类别和品牌进行多重路由控制，将订单消息发送到特定的队列中\n\nDirect(直连)交换机定义Direct 交换机根据消息的路由键将消息路由到与之完全匹配的队列中。适合处理一对一的消息发送场景\n优缺点\n优点\n支持通配符匹配路由键，可以根据消息的路由键将消息路由到多个队列中，适用于需要一对多的消息发送场景\n\n\n缺点\n相比直连交换机，Topic 交换机在处理消息时需要进行额外的匹配操作，处理效率略低\n\n\n\n适用场景举例:例如，在一个订单系统中，当一个订单创建时，需要将订单信息发送到一个特定的队列中，以便其他系统可以及时地处理这个订单。在这种情况下，可以使用 Direct 交换机根据订单号进行路由控制，将订单消息发送到特定的队列中\n\n路由键在 RabbitMQ 中，路由键是一个字符串，用于描述消息的路由信息。生产者在发送消息时可以指定路由键，消费者在绑定队列时也可以指定路由键。\n路由键与交换机的绑定方式不同，对于 Fanout 交换机来说，路由键会被忽略，消息会被广播到所有绑定到交换机上的队列中；对于 Direct 交换机和 Topic 交换机来说，路由键决定了消息被路由到哪个队列中。\n在 Direct 交换机和 Topic 交换机中，队列和交换机之间的绑定都是带有一个路由键的，当生产者发送消息时，需要指定消息的路由键，交换机会根据路由键将消息发送到对应的队列中。\n在 Topic 交换机中，路由键可以使用通配符来进行匹配。通配符有两种，分别是 *（匹配一个单词）和 #（匹配零个或多个单词），可以使用它们来实现更加灵活的路由控制。\nsg.#\nsg.slxsg.xh\n","categories":["OpenStack"]},{"title":"SASS 7+1模式","url":"/2023/CSS/scss_7+1/","content":"7+1 模式指的是通过一个文件和七个文件夹管理 CSS 样式\n1 个文件main.scss 是入口文件, 用于导入其他七个文件夹的 CSS 样式\n7 个文件夹\nabstracts\nbase\ncomponents\nlayout\npages\nthemes\nvendors\n\nBasebase 用于存放项目中的模板文件。定义一些 HTML 元素公认的标准样式\n\nLayoutlayout 用于存放构建网站或者应用很小使用到的布局部分\n\nComponentscomponents 包含各类具体模块，基本上是所有的独立模块\n\nPagespages 存放页面文件，就是那个页面内具有独特的样式\n\nThemethemes 主题文件夹, 每个文件存放着整个 app 的变量，组件的样式值基本引用于该文件\n\nAbstractabstract 辅助工具文件夹，可以存放每一个全局变量、函数、混合宏以及占位符\n\nVendorsvendors 外来项目文件夹，存放一些外部库和框架\n","categories":["CSS"]},{"title":"shell 判断","url":"/2022/Shell/shell_judge/","content":"shell 判断条件&#x2F;数值测试\nshell 条件测试\n数值比较\n文件测试\n字符串比较\n\n\n\n# 取出变量长度echo $&#123;#pass&#125;\n\n测试语法:\ntest &lt;条件表达式&gt;\n[ &lt;条件表达式&gt; ]\n[[ &lt;条件表达式&gt; ]]\n\n三种语法都可以用做测试\n echo $? 返回判断结果 若为真, 判断返回 0若为假, 判断返回 1\n数值比较:\ntest &lt;整数1&gt; &lt;操作符&gt; &lt;整数2&gt;; echo $?[ &lt;整数1&gt; &lt;操作符&gt; &lt;整数2&gt; ]; echo $?[[ &lt;整数1&gt; &lt;操作符&gt; &lt;整数2&gt; ]]; echo $?\n\n操作符:-gt 大于-lt 小于-eq 等于-ne 不等于-ge 大于等于-le 小于等于\n\nif 语法结构流程控制:\n\nif 如果\nthen 那么\nelse 否则\nfi 结束\n\nif &lt;条件&gt;then &lt;指令&gt;else &lt;指令&gt;fi\n\n#实例:#!/bin/bashread -p &quot;请输入您的密码: &quot; psif [ $&#123;#ps&#125; -lt 7 ]thenecho &quot;你的密码太短!&quot;elseecho &quot;您的密码真长!&quot;fi\n\n文件测试操作符:-f 判断文件是否存在, 是则返回真-b 判断文件是否是块文件, 是则返回真-d 判断是否是目录, 是则返回真\n-w 判断指定文件或目录是否可写-x 判断指定文件或目录是否可执行-e 判断指定文件或目录是否存在......\n文件测试语法\n[ &lt;操作符&gt; &lt;文件&gt; ]...\n\n#示例:#!/bin/bashread -p &quot;请输入要备份的目录: &quot; dir1if [ -d $dir1 ]then echo &quot;$dir1 存在可以备份&quot;else echo &quot;$dir1 不存在, 无法备份&quot;fi\n\n\n字符串比较操作符:= 等于!= 不等于-Z 判断字符长度是为 0-n 判断字符长度不是 0\n[ &lt;字符串&gt; = &lt;字符串&gt; ]\n\n#示例:#!/bin/bashread -p &quot;你确定要升级这件装备吗? [yes/no]&quot; selectif [ &quot;$select&quot; = &quot;yes&quot; ]thenecho &quot;装备升级开始...&quot;elseecho &quot;感谢你, 欢迎下次光临!&quot;fi\n\n混合测试操作符:&amp;&amp; 逻辑和, 等同于 -a|| 逻辑与, 等同于 -o\n正则表达式使用正则表达式开始 =~ 模糊查询判断正则表达式必须使用 [[ ]] 判断~ [@_!] 表示包含下列字符\n#示例#!/bin/bashread -p &quot;请你输入密码: &quot; passif [ $&#123;#pass&#125; -gt 7 ] &amp;&amp; [[ $pass =~ [a-z] ]] &amp;&amp; [[ $pass =~ [A-Z] ]] &amp;&amp; [[ $pass =~ [@_!] ]]thenecho &quot;你的密码够复杂&quot;elseecho &quot;你的密码太简单&quot;fi\n\n\n##流程控制\nif 流程控制\n单分支结构\n双分支结构\n多分支结构\n镶套结构\n\n#单分支if [ &lt;命令&gt; ]; then &lt;命令&gt;; fi#双分支if [ &lt;命令&gt; ]; then &lt;命令&gt;; else &lt;命令&gt;; fi#多分支if [ &lt;命令&gt; ]; then &lt;命令&gt;; elif [ &lt;命令&gt; ]; then &lt;命令&gt;;......; fi\n\n示例:\n#!/bin/bash#voilone#2022-09-12hour=`date+%H`          #date(时间命令) %Hif [ $hour -ge 6 -a $hour -le 10 ]          #-a 指and    then echo &quot;现在是早上&quot;elif [ $hour -ge 11 -a $hour -le 13 ]    then echo &quot;现在是中午&quot;elif [ $hour -ge 14 -a $hour -le 18 ]    then echo &quot;现在是下午&quot;else    echo &quot;现在是晚上&quot;fi\n\n嵌套if [ &lt;命令&gt; ] then &lt;命令&gt;    if [ &lt;命令&gt; ] then &lt;命令&gt;    else &lt;命令&gt;        fi;......\n\n调试脚本bash 和 sh 是一个程序\n#调试bash -n   &lt;shell脚本&gt;sh -n   &lt;shell脚本&gt;#无输出则表示无错误#边调试边执行sh -xv   &lt;脚本文件&gt;\n\n模式匹配 CASE#如果用户输入y, Y, 则if跳过.if [ $action = &quot;[yes/no]&quot; ]#case语法case &lt;变量&gt; in    &lt;模式1&gt; )    &lt;命令序列&gt;;;    &lt;模式2&gt; )    &lt;命令序列&gt;;;    &lt;模式3&gt; )    &lt;命令序列&gt;;;    #类似于else    *)esac\n\n例:\nread -p &quot;输入用户名: &quot; nameread -p &quot;确定吗 [yes/no]&quot; actioncase &quot;$action&quot; inY|y|Yes|YEs|YES|yES|yeS)id $nameecho &quot;用户为: $name&quot;;;*)echo &quot;thank you&quot;;;esac\n\n附加知识点输入重定向:\n# 可用于打印菜单# EOF为段落标记cat &lt;&lt; EOF1.2.3.4.EOF\n","categories":["Shell"]},{"title":"shell 数组和函数","url":"/2022/Shell/shell_array_function/","content":"shell 数组和函数\n数组数组: 用一个固定的字符串, 代替多个不固定的字符串\n数组类型普通数组#每个值对应一个索引name=abcd#打印对应的索引值(第一个是起始索引, 第二个是步长)echo $&#123;name:1:2&#125;#定义数组#narry: 数组名; (.. .. ..)数组元素narry=(man woman align unknow)#自定义索引mark=([3]=bilibili [2]=voiblog [1]=TC)#调用数组, [索引], [*]或[@]指选中所有索引echo $&#123;narry[*]&#125;#查看索引(!指取反)echo $&#123;!narry[*]&#125;\n\n\n\n\n\n值\na\nb\nc\nd\n\n\n\n索引\n0\n1\n2\n3\n\n\n\n使用例:\n#将指定文件的每一行作为元素赋值给pd数组pd=(&#x27;cat /etc/passwd&#x27;)#可以一次定义一个值narry[0]=&quot;myNarry&quot;#查看数组declare -a |grep &lt;数组名&gt;       #declare -a 查看所有变量\n\n关联数组#必须先声明关联数组declare -A &lt;数组名&gt;#自定义索引mark=([web]=bilibili [home]=voiblog [cloud]=TC)#调用数组元素echo $&#123;mark[web]&#125;\n\n\n\n\n\n值\nbilibili\nvoiblog\nTC\n\n\n\n索引\nweb\nhome\ncloud\n\n\n\nfor 定义数组:\n#通过循环定义和显示数组#例:#!/bin/bashnum=0                       #若num不声明, 则num++, num初始值为0; ++num, 初始值为1for i in &#x27;./test.txt&#x27;do    line[num++]=$idone#遍历数组for i in $&#123;!line[*]&#125;do    echo $jdone\n\n\n变量 IFS, 指定分割符, 用于更改 for 循环的分隔符1\n\n\n函数函数意为复用代码\n#函数定义test () &#123; echo &quot;这是函数&quot; &#125;function test &#123; echo &quot;另一种函数定义方法&quot; &#125;#函数的参数传递# $1 代表传入的第一个参数, 以此类推, $n 代表第n个参数# 当 n&gt;=10 时, 参数应写为 $&#123;n&#125;test () &#123;    echo &quot;$1&quot;&#125;#调用函数test &lt;参数1&gt; &lt;参数2&gt; ...\n\n特殊参数\n\n\n\n参数\n说明\n\n\n\n$?\n显示最后命令的退出状态. 0表示没有错误, 其他任何值表明有错误\n\n\n$#\n传递到脚本或函数的参数个数\n\n\n$*\n以一个单字符串显示所有向脚本传递的参数\n\n\nshift 移动参数(了解)2\n使参数产生位移\n1.变量名尚不确定, 请查阅网络资料 ↩2.了解 ↩","categories":["Shell"]},{"title":"shell循环","url":"/2022/Shell/shell_loop/","content":"shell 循环\nfor 循环语法结构:\nfor &lt;变量名&gt; in &lt;取值列表&gt;do&lt;循环体&gt;done\n\n案例:\n#&#123;1..10&#125;从1到10for i in &#123;1..10&#125;do    echo $i    sleep 3         #等待3秒done# $# 代表参数个数\n\n退出程序或循环:\n\nexit 退出整个程序\nbreak 退出当前循环程序\ncontinue 退出此次循环, 进行下一次循环\n\nwhile until 循环while 语法结构:\nwhile &lt;条件测试&gt;          #条件为真停止循环do&lt;循环体&gt;done\n\n于 while 差不多util 语法结构\nuntil &lt;条件测试&gt;          #条件为假停止循环do&lt;循环体&gt;done\n\nexpect 语言expect 为一门独立的语言用于完成自动交互, 即模拟人工输入的行为安装:\napt install expect tcl\n\n例:解决 ssh 交互\nvim ssh.exp#!/usr/bin/expect                   (这一段必须写)spawn ssh root@192.168.31.10        #spawn 启动一个shell程序expect &#123;    &quot;yes/no&quot;&#123;send &quot;yes\\r&quot;, exp_continue&#125;          #文本匹配到了什么, 就干什么; \\r为回车符;若没有&quot;yes/no&quot;, 用exp_continue跳过    &quot;password:&quot; &#123;send &quot;123456\\r&quot;&#125;;  #分号为结束符, 结束操作&#125;interact                           #保存交互界面#若不加interact, 会将程序杀死\n\n执行 expect 程序\n./ssh.exp\n","categories":["Shell"]},{"title":"初识shell","url":"/2022/Shell/shell_starter/","content":"初识 Shell\n\n\n什么是 shellshell: 壳(计算机壳层), 命令解释器\n结构图:\n\n\n第一个 shell 脚本vim first_shell.shecho &quot;Hello 2022!&quot;read -p &quot;请输入你的姓名: &quot; nameecho &quot;哈哈哈 $name 是帅哥&quot;\n\nshell 脚本的四种执行方式:\n\nbash first_shell.sh\nsh first_shell.sh\n. first_shell.sh\nsource first_shell.sh\n\n\n1 和 2 的执行方式, 是子 shell 执行(启动新的 shell 执行)3 和 4 的执行方式, 是本 shell 执行\n\nvim cd_dir.sh#!/bin/bash         此为脚本声明, !为起始符, 由/bin/bash执行cd ~/lspwd\n\n\nshell 变量用一个固定的字符串去表示不固定的内容, 便于修改\n\n自定义变量定义变量: 变量名=变量值变量不能以数字开头等号左右不能有空格\n\n推荐变量名命名大于 5 个字母\n#例:name=&quot;handsome_boy&quot;\n\n\n调用变量若需要提取变量的内容时, 需要在变量名之前加入 “$” 符号可以通过 echo 命令输出变量的值\n\n#例:[tourist@localhost ~]$ name=&quot;voilone&quot;[tourist@localhost ~]$ echo $name\n\n\n变量查看在不知道有什么 shell 变量时, 可以进行变量查看\n\nset\n\n\n变量删除若不想使用一个变量, 就可以删除该变量\n\nunset &lt;变量名&gt;\n\n\n编写脚本然后授权脚本\n\nchmod +x &lt;脚本名&gt;        #授权脚本后, 方可在本shell中执行\n\n三目表达式:&amp;&amp; 和 || 是三目表达式&amp;&amp; 前面的命令成功, 执行后面的命令|| 前面的命令失败, 执行后面的命令\n\n交互定义变量read 从键盘读入变量名赋值方式: read 变量名\n\nread -p &quot;请输入你的姓名: &quot; name     #&quot;-p&quot;选项指打印\n\n3 种引号:\n\n&quot;&quot; 弱引用\n&#39;&#39; 强引用\n`` 优先执行\n\n\n变量运算\n整数运算(四种方法等同)\n\n\nexpr\n$(())\n$[]\nlet\n\nexpr:\n#语法:expr 1 + 2expr $num1 + $num2# + 加# - 减# \\* 乘     (&quot;*&quot;代表任意字符, 要用&quot;\\&quot;转义一下)# / 除# % 取余\n\n脚本实例:\n#!/usr/binread -p &quot;请输入你的第一门成绩: &quot; mark1read -p &quot;请输入你的第二门成绩: &quot; mark2echo -n &quot;总成绩是: &quot;                            #-n选项用于去掉回车符expr $mark1 + $mark2\n\n$(()):\n#语法:echo $((5+2))echo $((2**3))...\n\n$[]:\necho $[5+2]...\n\nlet:\n#常用let sum=2+3echo $sum...\n","categories":["Shell"]},{"title":"shell 正则表达式","url":"/2022/Shell/shell_zzbds/","content":"正则表达式该笔记基于 shell正则表达式是一种字符模式, 用于查找过程中匹配指定字符[toc]\n\n初次使用例:匹配 ^a 以 a 开头的字符\n正则表达式可以被 vim, sed, awk, grep 调用\n#双括号用于放正则表达式#=~ 是正则表达式的开始(在判断语句中) if [[ $test =~ ^[0-9]+$  ]]    #+$ 以一个或多个数字结尾 then    echo &quot;正确&quot; else    echo &quot;错误&quot;fi\n\n\n基本正则表达式元字符定义: 用于表达不同于字面本身含义的字符\n\n被匹配文本示例: “ this is a great day.”\n\n^ 行首定位符grep ^this\n\n$ 行尾定位符grep day$\n\n. 匹配任意单个字符grep d.y\n\n* 匹配前导符 0 到多次前导符, ab*, b 为前导符\ngrep gre*\n\n.* 匹配任意多个字符grep g.*t\n\n[] 匹配指定范围内的一个字符grep [t]his\n\n[-] 匹配指定连续范围内的一个字符#[a-Z] = [a-zA-Z]grep [a-z]his\n\n[ ^ ] 匹配不在指定组内的字符grep [^0-9]his\n\n\\ 转义符grep day\\.\n\n\\&lt; 词首定位符(不同于行首定位符)grep \\&lt;this\n\n\\&gt; 词尾定位符grep day\\&gt;\n\n() 匹配稍后使用的字符标签#例:#将shell脚本注释:3,9 s/\\(.*\\)/#\\1/      #\\1 代表前方调用的括号\n\n&#123;&#125; 前导符出现 n 次字符出现指定次数才匹配\ngrep  m\\&#123;5\\&#125;    #m出现5次grep m\\&#123;5, \\&#125;   #m出现5次以上grep m\\&#123;5,10\\&#125;   #m仅出现5~10次\n\n\n扩展正则表达式元字符egrep 才能识别扩展元字符\negrep &lt;扩展元字符&gt;# grep -E 等价于 egrepgrep -E\n\n\n+ 匹配 1~n 个前导字符\n? 匹配 0~1 个前导字符\na|b 匹配 a 或 b\n() 组字符(用于组合匹配字符)egrep &quot;this(is|a)&quot;\n\n\n修饰符(待完善)\ngrepgrep -v &lt;字符&gt; &lt;文件&gt;       #匹配取反grep -q &lt;字符&gt; &lt;文件&gt;       #匹配静默(不显示匹配结果)grep &lt;字符&gt; -R &lt;目录&gt;       #查找目录下的文件grep -n                     #将行号显示出来grep -B2    #同时显示匹配的前两行     -A2    #同时显示匹配的后两行     -C2    #同时显示匹配的上下两行\n\n\nsed 流编辑器用于 shell 编程更改文件内容(免交互)\nsed -r      #使用正则表达式sed -i      #写入文件\n\n实例:不加入-i 选项, sed 只会写入缓存空间, 文件内容不会改变.\nsed -r &quot;/&lt;正则表达式&gt;/&lt;操作&gt;/&quot; &lt;文件&gt;sed -r &quot;#&lt;正则表达式&gt;#&lt;操作&gt;#&quot;sed -r &quot;/root/d&quot;  test.txt             #删除匹配的字符行, d为操作(删除)sed -r &quot;3d&quot;  test.txt                  #删除第3行字符sed -r &quot;3&#123;d&#125;&quot; test.txt                 # &#123;括号&#125;内可以加多个选项sed -r &quot;3,6d&quot;  test.txt                #删除3~6行字符sed -r &quot;d&quot;                             #删除尾行#替换文件字符sed -r &quot;s/替换前/替换后/&quot;                #替换字符(只换第一个)sed -r &quot;s/替换前/替换后/g&quot;               #替换字符(全局替换)sed -r &quot;s/替换前/&amp;.5/&quot;                  #调用匹配的字符, 结果为匹配字符后多了个.5sed &quot;s/(替换前)/\\1.5/&quot;                    #同上#读取操作sed -r &quot;r test.txt&quot; other.txt           #读取目标文件字符并逐行打印sed -r &quot;5r test.txt&quot; other.txt          #在第5行输出指定文件字符sed -r &quot;/string/r test.txt&quot; other.txt#写入操作sed -r &quot;w test.txt&quot; other.txt           #other.txt的内容会传入test.txtsed -r &quot;/string/w test.txt&quot; other.txt...#追加操作sed -r &quot;a string&quot; test.txt              #逐行追加字符sed -r &#x27;$a string&#x27; test.txt             #在文件尾行传入字符sed -r -e &lt;操作1&gt; -e &lt;操作2&gt; -e ...       #-e选项用于多重编辑\n\n\n\n\n操作字母\n操作\n操作字母\n操作\n\n\n\nd\n删除\nw\n写入(另存为)\n\n\ni\n插入\na\n追加\n\n\ns\n替换\nc\n整行替换\n\n\n&amp;\n调用\nn\n下一行\n\n\nr\n读取其他文件\n!\n取反\n\n\n\nawk 切片awk 切片技术\n初识 awk行: 记录(为$0)词: 字段(从第一个字段$1开始, 以此类推$2, $3, $4, …)每过一行都会重置变量\n#对awk, $0是一行记录awk &#x27;&#123;print $0&#125;&#x27; test.txt#-F 指定记录分割符(可选)awk -F:                     #指定冒号&quot;:&quot;为记录分隔符\n\nawk 语法#常用语法awk &lt;选项&gt; &#x27;&lt;命令&gt;&#x27; &lt;文件&gt;\n\nawk 有三种执行时态:\n\n开始 BEGIN&#123;&#125; 发生在行处理前(大小写敏感)\n现在 &#123;&#125; 在行处理时, 读一行执行一次\n结束 END&#123;&#125; 行处理后\n\n#例:awk &#x27;BEGIN&#123;print &quot;行处理前: &quot;&#125; &#123;print $1&#125; END&#123;print &quot;行处理后&quot;&#125;&#x27; test.txt\n\n内部变量\nFS 输入字段分隔符(默认为空格)\nOFS 输出字段分隔符\nRS 输入记录分隔符(默认换行符)\nFNR 多文件独立编号(类似行号)\nNR 多文件汇总编号\nNF 字段数\n. . . . . .\n\n#例:#以冒号为输入分隔符awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;print $1&#125;&#x27; test.txt#输出分隔符(效果为插入指定的分隔符)awk &#x27;BEGIN&#123;FS=&quot;:&quot;; OFS=&quot;666&quot;&#125; &#123;print $1,$2,$3&#125; END&#123;&#125;&#x27; test.txt\n\n格式化输出print 函数\n#例:date | awk &#x27;&#123;print &quot;当前年份: &quot; $1, &quot;\\n当前月份:&quot; $2&#125;&#x27;\n\n模式(正则表达式)和动作awk 语句由模式和动作组成, 每一次处理都会有动作模式常用正则表达式\n\n字符串比较\n\n#例:#正则表达式模式awk &#x27;/&lt;正则表达式&gt;/&#x27; &lt;文件&gt;# ~ 代表字符串比较awk &#x27;$0 ~/&lt;正则表达式&gt;/&#x27; test.txt\n\n\n数值比较\n\n#与多数编程语言的比较符相似awk &#x27;NR &lt; 10&#x27; test.txt#也可以进行运算awk &#x27;&#123;NR*2 &lt; 10&#125;&#x27; test.txt\n\n\n多条件\n\n#例:#逻辑或和与(|| &amp;&amp;)awk &#x27;~/&lt;正则表达式&gt;/ &amp;&amp; NR&lt;=5&#x27; test.txt...#范围模式#从第一个, 到第二个范围查找awk &#x27;/&lt;正则表达式&gt;/, /正则表达式/&#x27; test.txt\n\nawk 脚本编程\n变量\n# &quot;-v&quot; 调用系统变量#awk调用变量不需要&quot;$&quot;awk -v &lt;引用变量&gt;awk -v name=test &#x27;$1 == &lt;变量名&gt;&#x27; test.txtawk &#x27;$1 ~ &quot;&#x27;&quot;$name&quot;&#x27;&quot; &#x27; test.txt           #不介意使用\n\n\n判断语句\n#if语句if (&lt;条件&gt;) &#123;&lt;代码块&gt;&#125;......#与C差不多#例:awk &#x27;&#123;if ($1 == id) &#123;print &quot;查询成功!&quot;&#125;&#125;&#x27; test.txt\n\n\n循环有 for 和 while, 语句格式与 C 相似\n\n\n数组\n#定义:&lt;数组名&gt;[下标]=&lt;值&gt;\n\n\nP36 待观看","categories":["Shell"]},{"title":"SQL 概念","url":"/2023/DataBase/sql_concept/","content":"视图\n","categories":["DataBase"]},{"title":"SQL 语法","url":"/2023/DataBase/sql_syntax/","content":"SQL: 结构化查询语句 (Structured Query Language)\n\nDDL 数据定义语句DDL: 数据定义语句 (Data Definition Language)\n\n库\n建库\n\n-- 创建 example 库CREATE DATABASE example;\n\n\n删库\n\nDROP DATABASE example;\n\n\n其他\n\n-- 进入example库USE example;-- 查询当前库SELECT DATABASE();\n\n-- 指定字符集-- COLLATE 设置排序规则CREATE DATABASE example CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;\n\n表\n建表\n\nCREATE TABLE example;-- 查看表SHOW TABLES;\n\n\n实例:\n要注意的是, 枚举型数据 ENUM 只允许插入字母,下划线和数字的字符组合因此, 别想着在这里默认插入中文字符\nCREATE TABLE example.users(    id INT NOT NULL AUTO_INCREMENT,    name VARCHAR(10) NOT NULL,    gender ENUM(&quot;male&quot;, &quot;female&quot;) NOT NULL DEFAULT &quot;male&quot;,    age INT(12) NOT NULl,    PRIMARY KEY (id)    );\n\n\nDMLDML: 数据操作语句 (Data Manipulation Language)\n数据添加-- 部分插入数据INSERT INTO example.table (key1, key2, ...) VALUES (value1, value2, ...);-- 完整插入数据INSERT INTO example.table VALUES ( value1, value2, ...);\n\n\n数据删除注意, 如果省略了 WHERE, 整个表的记录都会被删除\nDELETE FROM example.tableWHERE id = 0;\n\n\n数据更新(修改)\n整个记录更新\n\n一定要指定 WHERE 否则所有记录都将更新\nUPDATE table_1 SET colum_1 = data_2  WHERE colum_1 = data_1;\n\n\nDQLDQL: Data Query Language\n特征是以 WHERE 开头\n\nIN 语句这一语句是用于过滤数据\n假设我们有一个名为表 test, 有 name 和 bender 两个字段我们只想查询性别为女的行(记录)就可以用到以下语句\nSELECT name,bender FROM test WHERE sex IN (&quot;male&quot;)\n\n\n多表联合查询INNER JOIN 内连接\nSELECT colum_1,cloum_2 FROM table_1INNER JOIN table2ON table_1.colum_1 = table_2.colum_3\n\n\n分组 GROUP By\n\n\nDCLDCL: Data Control Language\nCREATE TABLE students (    sid INT NOT NULL AUTO_INCREMENT,    stuname VARCHAR(20) NOT NULL,    stunum VARCHAR(20) NOT NULL,    stuage INT,    PRIMARY KEY (sid)    );\n\n\n其他修改 root 账户进入 mysql 库, 修改 user 表\n-- 调用加密函数-- 建议使用UPDATE mysql.user SET authentication_string=password(&quot;密码&quot;) WHERE user=&quot;root&quot;-- 未加密 密码UPDATE mysql.user SET authentication_string=&quot;密码&quot; WHERE user=&quot;root&quot;;\n","categories":["DataBase"]},{"title":"美化 Windows Terminal","url":"/2023/blog-archive/beautify_wt/","content":"美化 Windows Terminal\n要想达到示例图片的效果, 最好先安装特定的终端字体 Nerd-Fonts\n美化步骤:\n\n安装 Nerd-Fonts 字体\n安装 Oh My Posh\n\n\n字体Nerd-Fonts: https://github.com/ryanoasis/nerd-fonts/\n到 release 页面去下载发行的压缩包, 然后解压缩 (我下载的是 FiraCode)解压缩后, 选中所有字体, 然后右键点击安装字体\n待系统安装完字体后, 还需在在 Windows Terminal 中设置安装的字体\n到 设置 -&gt; 默认值 -&gt; 外观 -&gt; 字体 选择你安装的字体, 然后保存\n\nOh My PoshOh My Posh: https://ohmyposh.dev/\nOh My Posh 可通过微软商店或 winget 安装, 选择其中一个方法安装即可\n通过 winget 安装\nwinget install JanDeDobbeleer.OhMyPosh -s winget\n\n\n设置主题在 PowerShell 中列出主题\nGet-PoshThemes\n\n找到主题的配置文件路径, 用以下指令设置主题\noh-my-posh init pwsh --config &#x27;主题配置文件路径.omp.json&#x27; | Invoke-Expression\n\n\n默认启动# 如果报错, 运行下面一条命令notepad $PROFILE# 如果上一条命令没报错, 就不要执行该命令New-Item -Path $PROFILE -Type File -Force\n\nnotepad $PROFILE 命令会打开一个记事本接着把以下内容, 加入到打开的记事本中\noh-my-posh init pwsh | Invoke-Expression# 如果你要让 Windows Terminal 默认是你设置的主题, 就写入这个命令oh-my-posh init pwsh --config &#x27;主题配置文件路径.omp.json&#x27; | Invoke-Expression\n\n\nnotepad $PROFILE 本质上是编辑 PowerShell 的用户配置\n\n自定义主题待我研究研究…\n","categories":["blog_archive"],"tags":["Windows Terminal"]}]